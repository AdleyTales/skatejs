{
  "id": "pages\\guides\\getting-started.ts",
  "dependencies": [
    {
      "name": "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\tsconfig.json",
      "includedInParent": true,
      "mtime": 1533852749669
    },
    {
      "name":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\package.json",
      "includedInParent": true,
      "mtime": 1534115027496
    },
    {
      "name": "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\.babelrc",
      "includedInParent": true,
      "mtime": 1533796116874
    },
    {
      "name": "../../components/layout",
      "loc": { "line": 4, "column": 8 },
      "parent":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\pages\\guides\\getting-started.ts",
      "resolved":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\components\\layout.ts"
    },
    {
      "name": "../../components/marked",
      "loc": { "line": 5, "column": 8 },
      "parent":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\pages\\guides\\getting-started.ts",
      "resolved":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\components\\marked.ts"
    },
    {
      "name": "skatejs",
      "loc": { "line": 6, "column": 26 },
      "parent":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\pages\\guides\\getting-started.ts",
      "resolved":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\node_modules\\skatejs\\dist\\esm\\index.js"
    },
    {
      "name": "../../utils",
      "loc": { "line": 7, "column": 24 },
      "parent":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\pages\\guides\\getting-started.ts",
      "resolved":
        "C:\\Users\\tjshu\\Documents\\GitHub\\skatejs\\site\\utils\\index.ts"
    }
  ],
  "generated": {
    "js":
      "\"use strict\";\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _templateObject = _taggedTemplateLiteral([\"\\n        <x-layout title=\\\"Getting started\\\">\\n          <x-marked\\n            src=\\\"\", \"\\\"\\n          ></x-marked>\\n        </x-layout>\\n      \"], [\"\\n        <x-layout title=\\\"Getting started\\\">\\n          <x-marked\\n            src=\\\"\", \"\\\"\\n          ></x-marked>\\n        </x-layout>\\n      \"]);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _a;\nrequire(\"../../components/layout\");\nrequire(\"../../components/marked\");\nvar skatejs_1 = require(\"skatejs\");\nvar utils_1 = require(\"../../utils\");\nexports.default = skatejs_1.define((_a = function (_utils_1$Component) {\n  _inherits(_a, _utils_1$Component);\n\n  function _a() {\n    _classCallCheck(this, _a);\n\n    return _possibleConstructorReturn(this, (_a.__proto__ || Object.getPrototypeOf(_a)).apply(this, arguments));\n  }\n\n  _createClass(_a, [{\n    key: \"render\",\n    value: function render() {\n      return this.$(_templateObject, \"\\n              At its core, Skate is about creating\\n              [Custom Elements](https://w3c.github.io/webcomponents/spec/custom/). Skate\\n              provides a series of\\n              [mixin functions](/mixins)\\n              that enable you to control what your component can do.\\n\\n              For instance, Skate's main mixin, `withComponent`, is just a composition of all\\n              of Skate's other mixin behaviours:\\n\\n              * `withChildren` -- the generated element will react to changes to its child\\n                elements.\\n              * `withContext` -- the element will inherit context from components up the tree,\\n                like in React.\\n              * `withLifecycle` -- the element can use added sugar on top of the built-in\\n                lifecycle callbacks.\\n              * `withRenderer` -- the element can generate its own DOM and output it to a\\n                `renderRoot` (a `ShadowRoot` node by default).\\n              * `withUpdate` -- the generated element will react to changes on their props or\\n                HTML attributes.\\n\\n              Calling `withComponent()` gives you a Custom Element class constructor, which\\n              you can then extend to define your own elements.\\n\\n              Every mixin accepts an optional `Element` constructor as its only parameter,\\n              which allows you to extend virtually any element type in HTML!\\n\\n              ### Rendering an element\\n\\n              As an example, let's create a simple greeting component...\\n\\n              ```html\\n              <x-hello>Bob</x-hello>\\n              ```\\n\\n              ...such that when this element is rendered, the end-user will see `Hello, Bob!`.\\n\\n              We can define a Skate component that renders the contents of our Custom Element:\\n\\n              ```js\\n              import { withComponent } from 'skatejs';\\n\\n              const Component = withComponent();\\n\\n              class GreetingComponent extends Component {\\n                render() {\\n                  return 'Hello, <slot></slot>!';\\n                }\\n              }\\n\\n              customElements.define('x-hello', GreetingComponent);\\n              ```\\n\\n              > It's worth noting that while `withRenderer()` provides a very basic renderer that\\n              sets `innerHTML` using the return value of `render()`, it's not intended for complex\\n              usage. If you need events / props / efficient updates, you should use something\\n              like `@skatejs/renderer-preact`.\\n\\n              When this element is rendered, the DOM will look something like the following:\\n\\n              ```html\\n              <x-hello>\\n                #shadow-root\\n                  Hello, <slot></slot>!\\n                Bob\\n              </x-hello>\\n              ```\\n\\n              This is the utility that web components provide when using Custom Elements and\\n              the Shadow DOM.\\n\\n              Skate also allows **turning off Shadow DOM** if you don't wanna use it for\\n              various particular reasons. You can turn it off via `get renderRoot()` override:\\n\\n              > NOTE: by turning off Shadow DOM you cannot use <slot/> content projection\\n              > anymore by default, further tweaks needs to be applied\\n\\n              ```js\\n              import { withComponent, props } from 'skatejs';\\n\\n              // define base class without Shadow DOM\\n              const NoShadowComponent = class extends withComponent() {\\n                // you need to return where you want to render your content, in our case we wanna render directly to our custom element children\\n                get renderRoot() {\\n                  return this;\\n                }\\n              };\\n\\n              // use custom NoShadowComponent as a base class\\n              class GreetingComponent extends NoShadowComponent {\\n                static get props() {\\n                  return {\\n                    name: props.string\\n                  };\\n                }\\n                render({ name }) {\\n                  return `Hello, ${name}!`;\\n                }\\n              }\\n\\n              customElements.define('x-hello', GreetingComponent);\\n              ```\\n\\n              Now when you write:\\n\\n              ```html\\n              <x-hello name=\\\"Bob\\\"></x-hello>\\n              ```\\n\\n              When this element is rendered, the DOM will look something like the following:\\n\\n              ```html\\n              <x-hello>\\n                Hello, Bob!\\n              </x-hello>\\n              ```\\n\\n              ### Watching element properties and attributes\\n\\n              We can create a Skate component that watches for HTML attribute changes on\\n              itself:\\n\\n              ```js\\n              import { props, withComponent } from 'skatejs';\\n\\n              const Component = withComponent();\\n\\n              class GreetingComponent extends Component {\\n                static get props() {\\n                  return {\\n                    name: props.string\\n                  };\\n                }\\n                render({ name }) {\\n                  return `Hello, ${name}!`;\\n                }\\n              }\\n\\n              customElements.define('x-hello', GreetingComponent);\\n              ```\\n\\n              The resulting HTML when the element is rendered would look like this:\\n\\n              ```html\\n              <x-hello name=\\\"Bob\\\">\\n                #shadow-root\\n                  Hello, Bob!\\n              </x-hello>\\n              ```\\n\\n              Now, whenever the `name` property or attribute on the greeting component\\n              changes, the component will re-render.\\n\\n              ### Making your own mixins\\n\\n              In the previous examples, each component implements `render` method which\\n              returns a string. This is default \\\"renderer\\\" behaviour provided by Skate. You\\n              can define custom renderer as well by re-defining `renderer` all the time for\\n              every component or rather we can write a mixin and take advantage of prototype\\n              inheritance:\\n\\n              > NOTE: the `with` prefix is not mandatory, just a common practice for naming\\n              > HOCs and Mixins\\n\\n              ```js\\n              import { props, withComponent } from 'skatejs';\\n\\n              const withDangerouslyNaiveRenderer = (Base = HTMLElement) => {\\n                return class extends Base {\\n                  renderer(renderRoot, render) {\\n                    renderRoot.innerHtml = '';\\n                    renderRoot.appendChild(render());\\n                  }\\n                };\\n              };\\n\\n              const Component = withComponent(withDangerouslyNaiveRenderer());\\n\\n              class GreetingComponent extends Component {\\n                static get props() {\\n                  return {\\n                    name: props.string\\n                  };\\n                }\\n                render({ name }) {\\n                  const el = document.createElement('span');\\n                  el.innerHTML = `Hello, ${name}!`;\\n                  return el;\\n                }\\n              }\\n\\n              customElements.define('x-hello', GreetingComponent);\\n              ```\\n\\n              ### Rendering using other front-end libraries\\n\\n              Skate provides default renderer by setting return string of `render` method to\\n              your component root ( ShadowRoot by default ) via `innerHTML`. Besides that it\\n              allows you to hook to the renderer ( by defining custom renderer ), which gives\\n              you options to support just about every modern component-based front-end library\\n              &mdash; React, Preact, Vue... just provide a `render` to stamp out your\\n              component's HTML, a `renderer` to update the DOM with your HTML, and then it's\\n              all the same to Skate!\\n\\n              The Skate team have provided a few renderers for popular front-end libraries.\\n              See the section on [renderers](/renderers) for more info.\\n\\n              #### Using Skate with Preact\\n\\n              Instead of writing our own `renderer`, we could use a library like\\n              [Preact](https://preactjs.com/) to do the work for us. Skate provides a\\n              ready-made renderer for Preact; here's how we would update our previous greeting\\n              component to use it:\\n\\n              ```js\\n              /** @jsx h */\\n\\n              import { props, withComponent } from 'skatejs';\\n              import withRenderer from '@skatejs/renderer-preact';\\n              import { h } from 'preact';\\n\\n              const Component = withComponent(withRenderer());\\n\\n              customElements.define(\\n                'x-hello',\\n                class extends Component {\\n                  static get props() {\\n                    return {\\n                      name: props.string\\n                    };\\n                  }\\n                  render({ name }) {\\n                    return <span>Hello, {name}!</span>;\\n                  }\\n                }\\n              );\\n              ```\\n\\n              Now that the greeting component is rendered via Preact, when it renders, it only\\n              changes the part of the DOM that requires updating.\\n            \");\n    }\n  }]);\n\n  return _a;\n}(utils_1.Component), _a.is = 'x-pages-guides-getting-started', _a));",
    "map": {
      "mappings": [
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 1, "column": 0 },
          "generated": { "line": 17, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 1, "column": 0 },
          "generated": { "line": 17, "column": 8 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 1, "column": 0 },
          "generated": { "line": 17, "column": 33 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 2, "column": 0 },
          "generated": { "line": 18, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 2, "column": 0 },
          "generated": { "line": 18, "column": 8 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 2, "column": 0 },
          "generated": { "line": 18, "column": 33 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 4, "column": 0 },
          "generated": { "line": 19, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 4, "column": 0 },
          "generated": { "line": 19, "column": 4 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 4, "column": 0 },
          "generated": { "line": 19, "column": 16 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 4, "column": 0 },
          "generated": { "line": 19, "column": 24 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 4, "column": 0 },
          "generated": { "line": 19, "column": 33 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 4, "column": 0 },
          "generated": { "line": 19, "column": 34 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 6, "column": 0 },
          "generated": { "line": 20, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 6, "column": 0 },
          "generated": { "line": 20, "column": 4 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 6, "column": 0 },
          "generated": { "line": 20, "column": 14 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 6, "column": 0 },
          "generated": { "line": 20, "column": 22 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 6, "column": 0 },
          "generated": { "line": 20, "column": 35 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 6, "column": 0 },
          "generated": { "line": 20, "column": 36 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 0 },
          "generated": { "line": 21, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 0 },
          "generated": { "line": 21, "column": 8 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 0 },
          "generated": { "line": 21, "column": 15 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 15 },
          "generated": { "line": 21, "column": 18 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 15 },
          "generated": { "line": 21, "column": 28 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 15 },
          "generated": { "line": 21, "column": 34 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 21, "column": 36 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 22, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 24, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 25, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 27, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 28, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 30, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 31, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 32, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 11, "column": 10 },
          "generated": { "line": 32, "column": 29 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 12, "column": 6 },
          "generated": { "line": 33, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 12, "column": 13 },
          "generated": { "line": 33, "column": 13 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 12, "column": 18 },
          "generated": { "line": 33, "column": 18 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 12, "column": 6 },
          "generated": { "line": 33, "column": 19 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 259, "column": 5 },
          "generated": { "line": 34, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 35, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 37, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 38, "column": 0 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 9, "column": 16 },
          "generated": { "line": 38, "column": 2 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 9, "column": 16 },
          "generated": { "line": 38, "column": 10 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 38, "column": 19 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 10, "column": 11 },
          "generated": { "line": 38, "column": 22 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 10, "column": 11 },
          "generated": { "line": 38, "column": 25 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 10, "column": 11 },
          "generated": { "line": 38, "column": 27 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 10, "column": 16 },
          "generated": { "line": 38, "column": 30 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 21 },
          "generated": { "line": 38, "column": 62 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 15 },
          "generated": { "line": 38, "column": 66 }
        },
        {
          "source": "pages\\guides\\getting-started.ts",
          "name": null,
          "original": { "line": 8, "column": 0 },
          "generated": { "line": 38, "column": 68 }
        }
      ],
      "sources": {
        "pages\\guides\\getting-started.ts":
          "import '../../components/layout';\nimport '../../components/marked';\n\nimport { define } from 'skatejs';\n\nimport { Component } from '../../utils';\n\nexport default define(\n  class extends Component {\n    static is = 'x-pages-guides-getting-started';\n    render() {\n      return this.$`\n        <x-layout title=\"Getting started\">\n          <x-marked\n            src=\"${`\n              At its core, Skate is about creating\n              [Custom Elements](https://w3c.github.io/webcomponents/spec/custom/). Skate\n              provides a series of\n              [mixin functions](/mixins)\n              that enable you to control what your component can do.\n\n              For instance, Skate's main mixin, \\`withComponent\\`, is just a composition of all\n              of Skate's other mixin behaviours:\n\n              * \\`withChildren\\` -- the generated element will react to changes to its child\n                elements.\n              * \\`withContext\\` -- the element will inherit context from components up the tree,\n                like in React.\n              * \\`withLifecycle\\` -- the element can use added sugar on top of the built-in\n                lifecycle callbacks.\n              * \\`withRenderer\\` -- the element can generate its own DOM and output it to a\n                \\`renderRoot\\` (a \\`ShadowRoot\\` node by default).\n              * \\`withUpdate\\` -- the generated element will react to changes on their props or\n                HTML attributes.\n\n              Calling \\`withComponent()\\` gives you a Custom Element class constructor, which\n              you can then extend to define your own elements.\n\n              Every mixin accepts an optional \\`Element\\` constructor as its only parameter,\n              which allows you to extend virtually any element type in HTML!\n\n              ### Rendering an element\n\n              As an example, let's create a simple greeting component...\n\n              \\`\\`\\`html\n              <x-hello>Bob</x-hello>\n              \\`\\`\\`\n\n              ...such that when this element is rendered, the end-user will see \\`Hello, Bob!\\`.\n\n              We can define a Skate component that renders the contents of our Custom Element:\n\n              \\`\\`\\`js\n              import { withComponent } from 'skatejs';\n\n              const Component = withComponent();\n\n              class GreetingComponent extends Component {\n                render() {\n                  return 'Hello, <slot></slot>!';\n                }\n              }\n\n              customElements.define('x-hello', GreetingComponent);\n              \\`\\`\\`\n\n              > It's worth noting that while \\`withRenderer()\\` provides a very basic renderer that\n              sets \\`innerHTML\\` using the return value of \\`render()\\`, it's not intended for complex\n              usage. If you need events / props / efficient updates, you should use something\n              like \\`@skatejs/renderer-preact\\`.\n\n              When this element is rendered, the DOM will look something like the following:\n\n              \\`\\`\\`html\n              <x-hello>\n                #shadow-root\n                  Hello, <slot></slot>!\n                Bob\n              </x-hello>\n              \\`\\`\\`\n\n              This is the utility that web components provide when using Custom Elements and\n              the Shadow DOM.\n\n              Skate also allows **turning off Shadow DOM** if you don't wanna use it for\n              various particular reasons. You can turn it off via \\`get renderRoot()\\` override:\n\n              > NOTE: by turning off Shadow DOM you cannot use <slot/> content projection\n              > anymore by default, further tweaks needs to be applied\n\n              \\`\\`\\`js\n              import { withComponent, props } from 'skatejs';\n\n              // define base class without Shadow DOM\n              const NoShadowComponent = class extends withComponent() {\n                // you need to return where you want to render your content, in our case we wanna render directly to our custom element children\n                get renderRoot() {\n                  return this;\n                }\n              };\n\n              // use custom NoShadowComponent as a base class\n              class GreetingComponent extends NoShadowComponent {\n                static get props() {\n                  return {\n                    name: props.string\n                  };\n                }\n                render({ name }) {\n                  return \\`Hello, \\${name}!\\`;\n                }\n              }\n\n              customElements.define('x-hello', GreetingComponent);\n              \\`\\`\\`\n\n              Now when you write:\n\n              \\`\\`\\`html\n              <x-hello name=\"Bob\"></x-hello>\n              \\`\\`\\`\n\n              When this element is rendered, the DOM will look something like the following:\n\n              \\`\\`\\`html\n              <x-hello>\n                Hello, Bob!\n              </x-hello>\n              \\`\\`\\`\n\n              ### Watching element properties and attributes\n\n              We can create a Skate component that watches for HTML attribute changes on\n              itself:\n\n              \\`\\`\\`js\n              import { props, withComponent } from 'skatejs';\n\n              const Component = withComponent();\n\n              class GreetingComponent extends Component {\n                static get props() {\n                  return {\n                    name: props.string\n                  };\n                }\n                render({ name }) {\n                  return \\`Hello, \\${name}!\\`;\n                }\n              }\n\n              customElements.define('x-hello', GreetingComponent);\n              \\`\\`\\`\n\n              The resulting HTML when the element is rendered would look like this:\n\n              \\`\\`\\`html\n              <x-hello name=\"Bob\">\n                #shadow-root\n                  Hello, Bob!\n              </x-hello>\n              \\`\\`\\`\n\n              Now, whenever the \\`name\\` property or attribute on the greeting component\n              changes, the component will re-render.\n\n              ### Making your own mixins\n\n              In the previous examples, each component implements \\`render\\` method which\n              returns a string. This is default \"renderer\" behaviour provided by Skate. You\n              can define custom renderer as well by re-defining \\`renderer\\` all the time for\n              every component or rather we can write a mixin and take advantage of prototype\n              inheritance:\n\n              > NOTE: the \\`with\\` prefix is not mandatory, just a common practice for naming\n              > HOCs and Mixins\n\n              \\`\\`\\`js\n              import { props, withComponent } from 'skatejs';\n\n              const withDangerouslyNaiveRenderer = (Base = HTMLElement) => {\n                return class extends Base {\n                  renderer(renderRoot, render) {\n                    renderRoot.innerHtml = '';\n                    renderRoot.appendChild(render());\n                  }\n                };\n              };\n\n              const Component = withComponent(withDangerouslyNaiveRenderer());\n\n              class GreetingComponent extends Component {\n                static get props() {\n                  return {\n                    name: props.string\n                  };\n                }\n                render({ name }) {\n                  const el = document.createElement('span');\n                  el.innerHTML = \\`Hello, \\${name}!\\`;\n                  return el;\n                }\n              }\n\n              customElements.define('x-hello', GreetingComponent);\n              \\`\\`\\`\n\n              ### Rendering using other front-end libraries\n\n              Skate provides default renderer by setting return string of \\`render\\` method to\n              your component root ( ShadowRoot by default ) via \\`innerHTML\\`. Besides that it\n              allows you to hook to the renderer ( by defining custom renderer ), which gives\n              you options to support just about every modern component-based front-end library\n              &mdash; React, Preact, Vue... just provide a \\`render\\` to stamp out your\n              component's HTML, a \\`renderer\\` to update the DOM with your HTML, and then it's\n              all the same to Skate!\n\n              The Skate team have provided a few renderers for popular front-end libraries.\n              See the section on [renderers](/renderers) for more info.\n\n              #### Using Skate with Preact\n\n              Instead of writing our own \\`renderer\\`, we could use a library like\n              [Preact](https://preactjs.com/) to do the work for us. Skate provides a\n              ready-made renderer for Preact; here's how we would update our previous greeting\n              component to use it:\n\n              \\`\\`\\`js\n              /** @jsx h */\n\n              import { props, withComponent } from 'skatejs';\n              import withRenderer from '@skatejs/renderer-preact';\n              import { h } from 'preact';\n\n              const Component = withComponent(withRenderer());\n\n              customElements.define(\n                'x-hello',\n                class extends Component {\n                  static get props() {\n                    return {\n                      name: props.string\n                    };\n                  }\n                  render({ name }) {\n                    return <span>Hello, {name}!</span>;\n                  }\n                }\n              );\n              \\`\\`\\`\n\n              Now that the greeting component is rendered via Preact, when it renders, it only\n              changes the part of the DOM that requires updating.\n            `}\"\n          ></x-marked>\n        </x-layout>\n      `;\n    }\n  }\n);\n"
      },
      "lineCount": null
    }
  },
  "hash": "0921b03daba62237592f4cb5cf8a648e",
  "cacheData": { "env": {} }
}
