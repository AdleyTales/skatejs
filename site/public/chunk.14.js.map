{"version":3,"sources":["webpack:///chunk.14.js","webpack:///./pages/utils/shadow.js"],"names":["webpackJsonp","275","module","exports","__webpack_require__","Object","defineProperty","value","_templateObject","strings","raw","freeze","defineProperties","_utils","default","component","this","$"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAAUC,EAAQC,EAASC,GAEjC,YAGAC,QAAOC,eAAeH,EAAS,cAC7BI,OAAO,GAGT,IAAIC,GAQJ,SAAgCC,EAASC,GAAO,MAAOL,QAAOM,OAAON,OAAOO,iBAAiBH,GAAWC,KAAOH,MAAOF,OAAOM,OAAOD,SARtF,2DAA4D,uCAAwC,2DAA4D,sCCV9MN,GAAA,IACAA,EAAA,GAEA,IAAAS,GAAAT,EAAA,GDiBAD,GAAQW,SCfO,EAAAD,EAAAE,WAAU,WACvB,MAAOC,MAAKC,EAAZT,EAAA","file":"chunk.14.js","sourcesContent":["webpackJsonp([14],{\n\n/***/ 275:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _templateObject = _taggedTemplateLiteral(['\\n    <x-layout title=\"shadow()\">\\n      <x-marked src=\"', '\"></x-marked>\\n    </x-layout>\\n  '], ['\\n    <x-layout title=\"shadow()\">\\n      <x-marked src=\"', '\"></x-marked>\\n    </x-layout>\\n  ']);\n\n__webpack_require__(33);\n\n__webpack_require__(27);\n\nvar _utils = __webpack_require__(24);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nexports.default = (0, _utils.component)(function utilsShadow() {\n  return this.$(_templateObject, '\\n        The `shadow()` function will create a `shadowRoot`, if one does not exist, and return it. Subsequent calls simply return the existing shadow root to prevent errors related to calling `attachShadow()` more than once.\\n\\n        Normally, when you\\'re writing custom elements without any tools, you\\'d want to attach your root in the `constructor()` and then do your rendering work in `connectedCallback()`. This is because the `connectedCallback` can get called more than once. For example:\\n\\n        ```js\\n        class CustomElement extends HTMLElement {\\n          constructor() {\\n            super();\\n            this.attachShadow({ mode: \\'open\\' });\\n          }\\n          connectedCallback() {\\n            this.shadowRoot.innerHTML = \\'Hello, World!\\';\\n          }\\n        }\\n        ```\\n\\n        If you\\'re using the `shadow()` function, you can just put everything into the `connectedCallback()`.\\n\\n        ```js\\n        import { shadow } from \\'skatejs\\';\\n\\n        class CustomElement extends HTMLElement {\\n          connectedCallback() {\\n            shadow(this).innerHTML = \\'Hello, World!\\';\\n          }\\n        }\\n        ```\\n\\n        > Skate uses this function internally in the `withRenderer()` mixin as the default return value from `renderRoot`.\\n      ');\n});\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// chunk.14.js","// @flow\n\nimport '../../components/layout';\nimport '../../components/marked';\n\nimport { component } from '../../utils';\n\nexport default component(function utilsShadow() {\n  return this.$`\n    <x-layout title=\"shadow()\">\n      <x-marked src=\"${`\n        The \\`shadow()\\` function will create a \\`shadowRoot\\`, if one does not exist, and return it. Subsequent calls simply return the existing shadow root to prevent errors related to calling \\`attachShadow()\\` more than once.\n\n        Normally, when you're writing custom elements without any tools, you'd want to attach your root in the \\`constructor()\\` and then do your rendering work in \\`connectedCallback()\\`. This is because the \\`connectedCallback\\` can get called more than once. For example:\n\n        \\`\\`\\`js\n        class CustomElement extends HTMLElement {\n          constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n          }\n          connectedCallback() {\n            this.shadowRoot.innerHTML = 'Hello, World!';\n          }\n        }\n        \\`\\`\\`\n\n        If you're using the \\`shadow()\\` function, you can just put everything into the \\`connectedCallback()\\`.\n\n        \\`\\`\\`js\n        import { shadow } from 'skatejs';\n\n        class CustomElement extends HTMLElement {\n          connectedCallback() {\n            shadow(this).innerHTML = 'Hello, World!';\n          }\n        }\n        \\`\\`\\`\n\n        > Skate uses this function internally in the \\`withRenderer()\\` mixin as the default return value from \\`renderRoot\\`.\n      `}\"></x-marked>\n    </x-layout>\n  `;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./pages/utils/shadow.js"],"sourceRoot":""}