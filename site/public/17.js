(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{231:function(e,n){e.exports='<with-update name="You"></with-update>\n'},232:function(e,n){e.exports="import { props, shadow, withUpdate } from 'skatejs';\n\nclass WithUpdate extends withUpdate() {\n  static get props() {\n    return {\n      name: props.string\n    };\n  }\n  updated() {\n    shadow(this).innerHTML = `Hello, ${this.name}!`;\n  }\n}\n\ncustomElements.define('with-update', WithUpdate);\n"},233:function(e,n,t){"use strict";var a=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),r=t(8);var o=function(e){function n(){return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),function(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}(n,(0,r.withUpdate)()),a(n,[{key:"updated",value:function(){(0,r.shadow)(this).innerHTML="Hello, "+this.name+"!"}}],[{key:"props",get:function(){return{name:r.props.string}}}]),n}();customElements.define("with-update",o)},234:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var a,r,o,i=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),s=function(e,n){return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(['\n      <x-layout title="Update">\n        <x-marked src="','"></x-marked>\n        <x-runnable\n          code="','"\n          html="','"\n        ></x-runnable>\n        <x-marked src="','"></x-marked>\n      </x-layout>\n    '],['\n      <x-layout title="Update">\n        <x-marked src="','"></x-marked>\n        <x-runnable\n          code="','"\n          html="','"\n        ></x-runnable>\n        <x-marked src="','"></x-marked>\n      </x-layout>\n    ']);t(29),t(25),t(28);var u=t(8),p=t(21);t(233);var l=c(t(232)),h=c(t(231));function c(e){return e&&e.__esModule?e:{default:e}}var d=(0,u.define)((o=r=function(e){function n(){return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),function(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}(n,p.Component),i(n,[{key:"render",value:function(){return this.$(s,"\n          The <code>withUpdate</code> mixin is the heart of Skate and is what\n          makes attribute / property linkage and reflection manageable by\n          enforcing a convention that follows best-practices. It also exports\n          several pre-defined property types that handle serialisation and\n          deserialisation to / from attributes when they're set, as well as\n          coercion when the property is set. When properties update, everything\n          funnels into a single set of functions that are called so that you can\n          update your component in a functional manner.\n        ",l.default,h.default,"\n          In the above example, we use the bare minimum setup and use the `updated()` callback to implement a very simple renderer. We've done this for the sake of example.\n\n          If we query the DOM for an instance of the element that we defined in the above example, we can update its props and the content will update. Suppose we have the following HTML using the above example's `with-update` element:\n\n          ```html\n          <with-update name=\"world\"></with-update>\n          ```\n\n          We can update the `name` prop in several ways to make the content update:\n\n          ```js\n          // first get a reference:\n          const element = document.querySelector('with-update')\n\n\n          // then do one of the following:\n          element.name = 'Joe';\n          element.props = { name: 'Joe' };\n          element.setAttribute('name', 'Joe');\n          ```\n\n          If you want to implement your own renderer, you should use the `withRenderer` mixin.\n\n          That's why when you use the `withComponent` mixin, you get both `withRenderer` and `withUpdate` and can just do something like:\n\n          ```js\n          class WithUpdate extends withComponent() {\n            static get props() {\n              return {\n                name: props.string\n              };\n            }\n            render() {\n              return `Hello, ${this.name}!`;\n            }\n          }\n          ```\n\n          ### Maintaining internal state\n\n          Up until now, we've just seen props. However, that is your public API. If you update your public API from within your component, you're likely breaking the expectations of your consumers. For this reason, Skate provides a way to maintain internal state just like in other functional UI abstractions like Preact and React.\n\n          ```js\n          import { withComponent } from 'skatejs';\n\n          class Input extends withComponent(withPreact()) {\n            state = {\n              value: ''\n            };\n            constructor() {\n              super();\n              this.addEventListener('change', e => {\n                this.state = {\n                  value: e.target.value\n                };\n              });\n            }\n            render({ state }) {\n              return `<input value={state.value}>`;\n            }\n          }\n          ```\n\n          ### Mixing state and props\n\n          In the above example, there's no way for a consumer to specify a value, or a default value. There's two scenarios you may want to cover.\n\n          1. Props overrides state. This is a controlled component.\n          2. State overrides props. This is an uncontrolled component.\n\n          In a controlled setting, you're allowing the consumer to override your internal state. Your render may look something like:\n\n          ```js\n          render({ props, state }) {\n            return `<input value=\"${props.value || state.value}\">`;\n          }\n          ```\n\n          In an uncontrolled setting, you'd have the state override the props:\n\n          ```js\n          render({ props, state }) {\n            return `<input value=\"${state.value || props.value}\">`;\n          }\n          ```\n\n          In a real-world scenario, there may be more intriciacies to the implementation than what's shown here. The key here is that if you're allowing both, you're going to want one to take precedence over the other depending on your needs.\n\n          ### Preventing updates with shouldUpdate()\n\n          Something common to functional UI abstractions is the ability to prevent updates because some updates can be expensive and you may not want to unnecessarily update.\n\n          This example isn't necessarily expensive, however it shows how you can prevent a render based on the previous and current state. This will only update / render if the state has actually changed.\n\n          ```js\n          import { withComponent } from 'skatejs';\n\n          class Input extends withComponent() {\n            state = {\n              value: ''\n            };\n            constructor() {\n              super();\n              this.addEventListener('change', e => {\n                this.state = {\n                  value: e.target.value\n                };\n              });\n            }\n            shouldUpdate(prevProps, prevState) {\n              return prevState.value !== this.state.value\n            }\n            render({ state }) {\n              return `<input value={state.value}>`;\n            }\n          }\n          ```\n\n          ### Executing something on *all* updates with updating()\n\n          The `withUpdate` mixin provides an `updating()` callback that is executed on every single update. It is called before `shouldUpdate()` and even if it returns `false`.\n\n          ### Built-in props\n\n          Skate ships with several built-in props that solve many of the common situations that you'll encounter.\n\n          All built-in props exhibint the following behaviour with attributes:\n\n          1. They're linked to an attribute that has the same name as the property, but dash-cased.\n          2. Attribute binding is one-way: attribute updates affect the property, but not the other way around.\n\n          #### any\n\n          This provides you a way to have the default prop behaviour while allowing any value to come in.\n\n          #### array\n\n          The `array` prop ensures that whatever is passed to the prop is coerced to an array. This means that a string would be made into an array where it is the only item in the array. When linked to an attribute, the value is JSON parsed / stringified as necessary.\n\n          #### boolean\n\n          The `boolean` prop coerces all values to a boolean. Attributes, when true, are void. When false, they're removed.\n\n          #### number\n\n          The `number` prop coerces all values to be a number.\n\n          #### object\n\n          The `object` prop ensures that a default, empty object is available. It doesn't coerce any values, like the `array` prop, but it does ensure that attribute values are JSON parsed / stringified.\n\n          #### string\n\n          The `string` prop ensures that whatever value is passed is coerced to a string.\n        ")}}]),n}(),r.is="x-pages-mixins-update",a=o))||a;n.default=d}}]);