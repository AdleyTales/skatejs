{"version":3,"sources":["webpack:///chunk.6.js","webpack:///./pages/mixins/with-update.js","webpack:///./pages/mixins/__samples__/with-update.js","webpack:///./pages/mixins/__samples__/with-update.js?a065","webpack:///./pages/mixins/__samples__/with-update.html"],"names":["webpackJsonp","153","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_templateObject","strings","raw","freeze","defineProperties","_utils","_withUpdate","_withUpdate2","_withUpdate3","_withUpdate4","component","this","$","style","context","154","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","target","props","i","length","descriptor","key","protoProps","staticProps","_skatejs","WithProps","_this","getPrototypeOf","attachShadow","mode","state","shadowRoot","innerHTML","name","withUpdate","string","customElements","define","155","156"],"mappings":"AAAAA,cAAc,IAERC,IACA,SAAUC,EAAQC,EAASC,GAEjC,YAyBA,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAtBvFG,OAAOC,eAAeP,EAAS,cAC7BQ,OAAO,GAGT,IAAIC,GAoBJ,SAAgCC,EAASC,GAAO,MAAOL,QAAOM,OAAON,OAAOO,iBAAiBH,GAAWC,KAAOH,MAAOF,OAAOM,OAAOD,SApBtF,0CAA2C,moBAAooB,WAAY,yCAA0C,0CAA2C,moBAAooB,WAAY,wCCV98CV,GAAA,IACAA,EAAA,GAEA,IAAAa,GAAAb,EAAA,GAEAA,GAAA,IACA,IAAAc,GAAAd,EAAA,KDgBIe,EAAed,EAAuBa,GCf1CE,EAAAhB,EAAA,KDmBIiB,EAAehB,EAAuBe,EAM1CjB,GAAQK,SCvBO,EAAAS,EAAAK,WAAU,WACvB,MAAOC,MAAKC,EAAZZ,GAEM,EAAAK,EAAAQ,OAAMF,KAAKG,QAAQD,OAFzBN,EAAAX,QAAAa,EAAAb,YD4BImB,IACA,SAAUzB,EAAQC,EAASC,GAEjC,YAOA,SAASwB,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMC,GAAQ,IAAKD,EAAQ,KAAM,IAAIE,gBAAe,4DAAgE,QAAOD,GAAyB,gBAATA,IAAqC,kBAATA,GAA8BD,EAAPC,EAElO,QAASE,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIP,WAAU,iEAAoEO,GAAeD,GAASE,UAAY9B,OAAO+B,OAAOF,GAAcA,EAAWC,WAAaE,aAAe9B,MAAO0B,EAAUK,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeN,IAAY7B,OAAOoC,eAAiBpC,OAAOoC,eAAeR,EAAUC,GAAcD,EAASS,UAAYR,GARje,GAAIS,GAAe,WAAc,QAAS/B,GAAiBgC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWV,WAAaU,EAAWV,aAAc,EAAOU,EAAWR,cAAe,EAAU,SAAWQ,KAAYA,EAAWT,UAAW,GAAMlC,OAAOC,eAAesC,EAAQI,EAAWC,IAAKD,IAAiB,MAAO,UAAUtB,EAAawB,EAAYC,GAAiJ,MAA9HD,IAAYtC,EAAiBc,EAAYS,UAAWe,GAAiBC,GAAavC,EAAiBc,EAAayB,GAAqBzB,ME9ChiB0B,EAAApD,EAAA,GAEMqD,EFsDU,SAAUvC,GE7CxB,QAAAuC,KAAc7B,EAAAL,KAAAkC,EAAA,IAAAC,GAAA1B,EAAAT,MAAAkC,EAAAX,WAAArC,OAAAkD,eAAAF,IAAAvB,KAAAX,MAAA,OAEZmC,GAAKE,cAAeC,KAAM,SAFdH,EFoFd,MAtCAtB,GAAUqB,EAAWvC,GAgBrB6B,EAAaU,IACXJ,IAAK,WACL1C,MAAO,SE1DAsC,OFgEPI,IAAK,eACL1C,MAAO,SE7DIsC,EAAOa,GAClB,OAAO,KFmEPT,IAAK,UACL1C,MAAO,WE/DPY,KAAKwC,WAAWC,UAAhB,QAAoCzC,KAAK0C,KAAzC,QFoEKR,IE7Fe,EAAAD,EAAAU,cAAlBT,GAEGR,OAILgB,KAAMT,EAAAP,MAAMkB,QAuBhBC,eAAeC,OAAO,cAAeZ,IF+E/Ba,IACA,SAAUpE,EAAQC,GG/GxBD,EAAAC,QAAA,k6BHqHMoE,IACA,SAAUrE,EAAQC,GItHxBD,EAAAC,QAAA","file":"chunk.6.js","sourcesContent":["webpackJsonp([6],{\n\n/***/ 153:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _templateObject = _taggedTemplateLiteral(['\\n    <x-layout title=\"Update\">\\n      ', '\\n      <p>\\n        The <code>withUpdate</code> mixin is the heart of Skate and is what\\n        makes attribute / property linkage and reflection manageable by\\n        enforcing a convention that follows best-practices. It also exports\\n        several pre-defined property types that handle serialisation and\\n        deserialisation to / from attributes when they\\'re set, as well as\\n        coercion when the property is set. When properties update, everything\\n        funnels into a single set of functions that are called so that you can\\n        update your component in a functional manner.\\n      </p>\\n      <x-runnable code=\"', '\" html=\"', '\"></x-runnable>\\n    </x-layout>\\n  '], ['\\n    <x-layout title=\"Update\">\\n      ', '\\n      <p>\\n        The <code>withUpdate</code> mixin is the heart of Skate and is what\\n        makes attribute / property linkage and reflection manageable by\\n        enforcing a convention that follows best-practices. It also exports\\n        several pre-defined property types that handle serialisation and\\n        deserialisation to / from attributes when they\\'re set, as well as\\n        coercion when the property is set. When properties update, everything\\n        funnels into a single set of functions that are called so that you can\\n        update your component in a functional manner.\\n      </p>\\n      <x-runnable code=\"', '\" html=\"', '\"></x-runnable>\\n    </x-layout>\\n  ']);\n\n__webpack_require__(25);\n\n__webpack_require__(33);\n\nvar _utils = __webpack_require__(24);\n\n__webpack_require__(154);\n\nvar _withUpdate = __webpack_require__(155);\n\nvar _withUpdate2 = _interopRequireDefault(_withUpdate);\n\nvar _withUpdate3 = __webpack_require__(156);\n\nvar _withUpdate4 = _interopRequireDefault(_withUpdate3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nexports.default = (0, _utils.component)(function mixinsWithUpdate() {\n  return this.$(_templateObject, (0, _utils.style)(this.context.style), _withUpdate2.default, _withUpdate4.default);\n});\n\n/***/ }),\n\n/***/ 154:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _skatejs = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar WithProps = function (_withUpdate) {\n  _inherits(WithProps, _withUpdate);\n\n  function WithProps() {\n    _classCallCheck(this, WithProps);\n\n    var _this = _possibleConstructorReturn(this, (WithProps.__proto__ || Object.getPrototypeOf(WithProps)).call(this));\n\n    _this.attachShadow({ mode: 'open' });\n    return _this;\n  }\n\n  // Called when props have been set regardless of if they've changed.\n\n  // This is where you declare your props.\n\n\n  _createClass(WithProps, [{\n    key: 'updating',\n    value: function updating(props) {}\n\n    // Called to check whether or not the component should call\n    // updated(), much like React's shouldComponentUpdate().\n\n  }, {\n    key: 'shouldUpdate',\n    value: function shouldUpdate(props, state) {\n      return true;\n    }\n\n    // Called if shouldUpdate returned true.\n\n  }, {\n    key: 'updated',\n    value: function updated() {\n      this.shadowRoot.innerHTML = 'Hey, ' + this.name + '!';\n    }\n  }]);\n\n  return WithProps;\n}((0, _skatejs.withUpdate)());\n\nWithProps.props = {\n  // This will define a handler for the name attribute that will set the name\n  // prop. When the name prop is set, it will trigger an update allowing you\n  // to react to the changes in shouldUpdate.\n  name: _skatejs.props.string\n};\n\n\ncustomElements.define('with-update', WithProps);\n\n/***/ }),\n\n/***/ 155:\n/***/ (function(module, exports) {\n\nmodule.exports = \"import { props, withUpdate } from 'skatejs';\\n\\nclass WithProps extends withUpdate() {\\n  // This is where you declare your props.\\n  static props = {\\n    // This will define a handler for the name attribute that will set the name\\n    // prop. When the name prop is set, it will trigger an update allowing you\\n    // to react to the changes in shouldUpdate.\\n    name: props.string\\n  };\\n\\n  constructor() {\\n    super();\\n    this.attachShadow({ mode: 'open' });\\n  }\\n\\n  // Called when props have been set regardless of if they've changed.\\n  updating(props) {}\\n\\n  // Called to check whether or not the component should call\\n  // updated(), much like React's shouldComponentUpdate().\\n  shouldUpdate(props, state) {\\n    return true;\\n  }\\n\\n  // Called if shouldUpdate returned true.\\n  updated() {\\n    this.shadowRoot.innerHTML = `Hey, ${this.name}!`;\\n  }\\n}\\n\\ncustomElements.define('with-update', WithProps);\\n\"\n\n/***/ }),\n\n/***/ 156:\n/***/ (function(module, exports) {\n\nmodule.exports = \"<with-update name=\\\"You\\\"></with-update>\\n\"\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// chunk.6.js","// @flow\n\nimport '../../components/code';\nimport '../../components/layout';\n\nimport { component, style } from '../../utils';\n\nimport './__samples__/with-update';\nimport codeWithUpdate from '!raw-loader!./__samples__/with-update';\nimport codeWithUpdateHtml from '!raw-loader!./__samples__/with-update.html';\n\nexport default component(function mixinsWithUpdate() {\n  return this.$`\n    <x-layout title=\"Update\">\n      ${style(this.context.style)}\n      <p>\n        The <code>withUpdate</code> mixin is the heart of Skate and is what\n        makes attribute / property linkage and reflection manageable by\n        enforcing a convention that follows best-practices. It also exports\n        several pre-defined property types that handle serialisation and\n        deserialisation to / from attributes when they're set, as well as\n        coercion when the property is set. When properties update, everything\n        funnels into a single set of functions that are called so that you can\n        update your component in a functional manner.\n      </p>\n      <x-runnable code=\"${\n        codeWithUpdate\n      }\" html=\"${codeWithUpdateHtml}\"></x-runnable>\n    </x-layout>\n  `;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./pages/mixins/with-update.js","import { props, withUpdate } from 'skatejs';\n\nclass WithProps extends withUpdate() {\n  // This is where you declare your props.\n  static props = {\n    // This will define a handler for the name attribute that will set the name\n    // prop. When the name prop is set, it will trigger an update allowing you\n    // to react to the changes in shouldUpdate.\n    name: props.string\n  };\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n\n  // Called when props have been set regardless of if they've changed.\n  updating(props) {}\n\n  // Called to check whether or not the component should call\n  // updated(), much like React's shouldComponentUpdate().\n  shouldUpdate(props, state) {\n    return true;\n  }\n\n  // Called if shouldUpdate returned true.\n  updated() {\n    this.shadowRoot.innerHTML = `Hey, ${this.name}!`;\n  }\n}\n\ncustomElements.define('with-update', WithProps);\n\n\n\n// WEBPACK FOOTER //\n// ./pages/mixins/__samples__/with-update.js","module.exports = \"import { props, withUpdate } from 'skatejs';\\n\\nclass WithProps extends withUpdate() {\\n  // This is where you declare your props.\\n  static props = {\\n    // This will define a handler for the name attribute that will set the name\\n    // prop. When the name prop is set, it will trigger an update allowing you\\n    // to react to the changes in shouldUpdate.\\n    name: props.string\\n  };\\n\\n  constructor() {\\n    super();\\n    this.attachShadow({ mode: 'open' });\\n  }\\n\\n  // Called when props have been set regardless of if they've changed.\\n  updating(props) {}\\n\\n  // Called to check whether or not the component should call\\n  // updated(), much like React's shouldComponentUpdate().\\n  shouldUpdate(props, state) {\\n    return true;\\n  }\\n\\n  // Called if shouldUpdate returned true.\\n  updated() {\\n    this.shadowRoot.innerHTML = `Hey, ${this.name}!`;\\n  }\\n}\\n\\ncustomElements.define('with-update', WithProps);\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/raw-loader!./pages/mixins/__samples__/with-update.js\n// module id = 155\n// module chunks = 6","module.exports = \"<with-update name=\\\"You\\\"></with-update>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/raw-loader!./pages/mixins/__samples__/with-update.html\n// module id = 156\n// module chunks = 6"],"sourceRoot":""}