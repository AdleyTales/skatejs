{"version":3,"sources":["webpack:///chunk.19.js","webpack:///./pages/renderers/index.js"],"names":["webpackJsonp","271","module","exports","__webpack_require__","Object","defineProperty","value","_templateObject","strings","raw","freeze","defineProperties","_utils","default","component","this","$"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAAUC,EAAQC,EAASC,GAEjC,YAGAC,QAAOC,eAAeH,EAAS,cAC7BI,OAAO,GAGT,IAAIC,GAUJ,SAAgCC,EAASC,GAAO,MAAOL,QAAOM,OAAON,OAAOO,iBAAiBH,GAAWC,KAAOH,MAAOF,OAAOM,OAAOD,SAVtF,4DAA6D,uCAAwC,4DAA6D,sCCVhNN,GAAA,IACAA,EAAA,IACAA,EAAA,GAEA,IAAAS,GAAAT,EAAA,GDkBAD,GAAQW,SChBO,EAAAD,EAAAE,WAAU,WACvB,MAAOC,MAAKC,EAAZT,EAAA","file":"chunk.19.js","sourcesContent":["webpackJsonp([19],{\n\n/***/ 271:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _templateObject = _taggedTemplateLiteral(['\\n    <x-layout title=\"Renderers\">\\n      <x-marked src=\"', '\"></x-marked>\\n    </x-layout>\\n  '], ['\\n    <x-layout title=\"Renderers\">\\n      <x-marked src=\"', '\"></x-marked>\\n    </x-layout>\\n  ']);\n\n__webpack_require__(25);\n\n__webpack_require__(33);\n\n__webpack_require__(26);\n\nvar _utils = __webpack_require__(24);\n\nfunction _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nexports.default = (0, _utils.component)(function mixins() {\n  return this.$(_templateObject, '\\n        Renderers are a way to take any UI library and essentially wrap a web\\n        component around it. We\\'ve provided renderers for some of the popular UI\\n        libraries:\\n\\n        - [LitHTML](/renderers/with-lit-html)\\n        - [Preact](/renderers/with-preact)\\n        - [React](/renderers/with-react)\\n\\n        Skate also ships with a super-simple\\n        [default renderer](/renderers/default) that\\n        simply sets `innerHTML`. It\\'s a fantastic way to mock up and\\n        write simple components without requiring a UI library.\\n\\n        ### Writing a renderer\\n\\n        The best way to write a renderer is to base it on the\\n        [`withRenderer`](/mixins/with-renderer)\\n        mixin API. To do this, you implement the `renderer` method on\\n        your class.\\n\\n        ```js\\n        interface Renderer {\\n          renderer(root: Node, render: Function): void;\\n        }\\n        ```\\n\\n        #### A simple implementation\\n\\n        An example of a simple, concrete implementation of this might be to\\n        write a renderer that simply sets `innerHTML`. This is the\\n        default behaviour provided by the default `renderer()` function and is\\n        great for mockups, simple or static components. It\\'s probably too naive\\n        for complex components that re-render a lot. However, it also serves as\\n        a fine example to show how to use the renderer API.\\n\\n        ```js\\n        // ./my-renderer.js\\n\\n        export default class extends HTMLElement {\\n          renderer(root, render) {\\n            root.innerHTML = render();\\n          }\\n        }\\n        ```\\n\\n        All this renderer does is simply set the `innerHTML` of the\\n        node that we\\'re supposed to render to. We\\'ve called this node the\\n        `root`.\\n\\n        The `render` argument is a bound function of the\\n        `render` method you define on your class. To use this\\n        renderer, you\\'d do something like:\\n\\n        ```js\\n        // ./my-component.js\\n\\n        import MyRenderer from \\'./my-renderer\\';\\n\\n        export default class extends MyRenderer {\\n          render() {\\n            return \\'Hello, World!\\';\\n          }\\n        }\\n        ```\\n\\n        > The `render` function is bound with the host element as\\n        `this` and the first argument, so you can also destructure in\\n        the function arguments, if you want to.\\n\\n        #### Hooking it up\\n\\n        The one problem here is that your component doesn\\'t yet know how to hook\\n        up `render` with `renderer` because you need to\\n        mixin `withRenderer`.\\n\\n        ```js\\n        // ./my-component.js\\n\\n        import { withRenderer } from \\'skatejs\\';\\n        import MyRenderer from \\'./my-renderer\\';\\n\\n        export default class extends withRenderer(MyRenderer) {\\n          render() {\\n            return \\'Hello, World!\\';\\n          }\\n        }\\n        ```\\n\\n        #### Reuse\\n\\n        If you want to make this renderer a bit more generic, you might want it\\n        to be able to accept other types of base classes, as opposed to having\\n        it fixed to `HTMLElement`. To do this, just make it a mixin.\\n        This consists of making it into a function that returns a class.\\n\\n        ```js\\n        // ./my-renderer.js\\n\\n        export default (Base = HTMLElement) =>\\n          class extends Base {\\n            renderer(root, render) {\\n              root.innerHTML = render();\\n            }\\n          }\\n        ```\\n\\n        And there you have your renderer that you can reuse with any component.\\n\\n        Taking the `render` example a bit further, it will now look\\n        something like:\\n\\n        ```js\\n        // ./my-component.js\\n\\n        import { withRenderer } from \\'skatejs\\';\\n        import myRenderer from \\'./my-renderer\\';\\n\\n        export default class extends withRenderer(myRenderer()) {\\n          render() {\\n            return \\'Hello, World!\\';\\n          }\\n        }\\n        ```\\n\\n        #### Responding to attributes and properties\\n\\n        This component doesn\\'t yet respond to property sets, or have any dynamic\\n        states. If we wanted to, say, accept a name property or attribute, we\\n        can mixin the `withUpdate` and `withRenderer`\\n        mixins with your renderer.\\n\\n        ```js\\n        // ./my-component.js\\n\\n        import { props, withRenderer, withUpdate } from \\'skatejs\\';\\n        import myRenderer from \\'./my-renderer\\';\\n\\n        export default class extends withRenderer(withUpdate(myRenderer())) {\\n          static props = {\\n            name: props.string\\n          };\\n          render({ name }) {\\n            return `Hello, ${name}!`;\\n          }\\n        }\\n        ```\\n\\n        This component would now render when both a `name` property\\n        _and_ a `name` attribute are set.\\n\\n        #### Simplifying as a base class\\n\\n        If you don\\'t want to repeat the mixin calls, simply make it a base\\n        class:\\n\\n        ```js\\n        // ./my-base.js\\n\\n        import { withRenderer, withUpdate } from \\'skatejs\\';\\n        import myRenderer from \\'./my-renderer\\';\\n\\n        export default myRenderer(withRenderer(withUpdate()));\\n        ```\\n\\n        > Your renderer can be composed into any point of your mixin chain, too!\\n\\n        Your component then can use it:\\n\\n        ```js\\n        // ./my-component.js\\n\\n        import { props } from \\'skatejs\\';\\n        import MyBase from \\'./my-base\\';\\n\\n        class MyComponent extends MyBase {\\n          static props = {\\n            name: props.string\\n          };\\n          render({ name }) {\\n            return `Hello, ${name}!`;\\n          }\\n        }\\n        ```\\n      ');\n});\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// chunk.19.js","// @flow\n\nimport '../../components/code';\nimport '../../components/layout';\nimport '../../components/primitives';\n\nimport { component, style } from '../../utils';\n\nexport default component(function mixins() {\n  return this.$`\n    <x-layout title=\"Renderers\">\n      <x-marked src=\"${`\n        Renderers are a way to take any UI library and essentially wrap a web\n        component around it. We've provided renderers for some of the popular UI\n        libraries:\n\n        - [LitHTML](/renderers/with-lit-html)\n        - [Preact](/renderers/with-preact)\n        - [React](/renderers/with-react)\n\n        Skate also ships with a super-simple\n        [default renderer](/renderers/default) that\n        simply sets \\`innerHTML\\`. It's a fantastic way to mock up and\n        write simple components without requiring a UI library.\n\n        ### Writing a renderer\n\n        The best way to write a renderer is to base it on the\n        [\\`withRenderer\\`](/mixins/with-renderer)\n        mixin API. To do this, you implement the \\`renderer\\` method on\n        your class.\n\n        \\`\\`\\`js\n        interface Renderer {\n          renderer(root: Node, render: Function): void;\n        }\n        \\`\\`\\`\n\n        #### A simple implementation\n\n        An example of a simple, concrete implementation of this might be to\n        write a renderer that simply sets \\`innerHTML\\`. This is the\n        default behaviour provided by the default \\`renderer()\\` function and is\n        great for mockups, simple or static components. It's probably too naive\n        for complex components that re-render a lot. However, it also serves as\n        a fine example to show how to use the renderer API.\n\n        \\`\\`\\`js\n        // ./my-renderer.js\n\n        export default class extends HTMLElement {\n          renderer(root, render) {\n            root.innerHTML = render();\n          }\n        }\n        \\`\\`\\`\n\n        All this renderer does is simply set the \\`innerHTML\\` of the\n        node that we're supposed to render to. We've called this node the\n        \\`root\\`.\n\n        The \\`render\\` argument is a bound function of the\n        \\`render\\` method you define on your class. To use this\n        renderer, you'd do something like:\n\n        \\`\\`\\`js\n        // ./my-component.js\n\n        import MyRenderer from './my-renderer';\n\n        export default class extends MyRenderer {\n          render() {\n            return 'Hello, World!';\n          }\n        }\n        \\`\\`\\`\n\n        > The \\`render\\` function is bound with the host element as\n        \\`this\\` and the first argument, so you can also destructure in\n        the function arguments, if you want to.\n\n        #### Hooking it up\n\n        The one problem here is that your component doesn't yet know how to hook\n        up \\`render\\` with \\`renderer\\` because you need to\n        mixin \\`withRenderer\\`.\n\n        \\`\\`\\`js\n        // ./my-component.js\n\n        import { withRenderer } from 'skatejs';\n        import MyRenderer from './my-renderer';\n\n        export default class extends withRenderer(MyRenderer) {\n          render() {\n            return 'Hello, World!';\n          }\n        }\n        \\`\\`\\`\n\n        #### Reuse\n\n        If you want to make this renderer a bit more generic, you might want it\n        to be able to accept other types of base classes, as opposed to having\n        it fixed to \\`HTMLElement\\`. To do this, just make it a mixin.\n        This consists of making it into a function that returns a class.\n\n        \\`\\`\\`js\n        // ./my-renderer.js\n\n        export default (Base = HTMLElement) =>\n          class extends Base {\n            renderer(root, render) {\n              root.innerHTML = render();\n            }\n          }\n        \\`\\`\\`\n\n        And there you have your renderer that you can reuse with any component.\n\n        Taking the \\`render\\` example a bit further, it will now look\n        something like:\n\n        \\`\\`\\`js\n        // ./my-component.js\n\n        import { withRenderer } from 'skatejs';\n        import myRenderer from './my-renderer';\n\n        export default class extends withRenderer(myRenderer()) {\n          render() {\n            return 'Hello, World!';\n          }\n        }\n        \\`\\`\\`\n\n        #### Responding to attributes and properties\n\n        This component doesn't yet respond to property sets, or have any dynamic\n        states. If we wanted to, say, accept a name property or attribute, we\n        can mixin the \\`withUpdate\\` and \\`withRenderer\\`\n        mixins with your renderer.\n\n        \\`\\`\\`js\n        // ./my-component.js\n\n        import { props, withRenderer, withUpdate } from 'skatejs';\n        import myRenderer from './my-renderer';\n\n        export default class extends withRenderer(withUpdate(myRenderer())) {\n          static props = {\n            name: props.string\n          };\n          render({ name }) {\n            return \\`Hello, \\${name}!\\`;\n          }\n        }\n        \\`\\`\\`\n\n        This component would now render when both a \\`name\\` property\n        _and_ a \\`name\\` attribute are set.\n\n        #### Simplifying as a base class\n\n        If you don't want to repeat the mixin calls, simply make it a base\n        class:\n\n        \\`\\`\\`js\n        // ./my-base.js\n\n        import { withRenderer, withUpdate } from 'skatejs';\n        import myRenderer from './my-renderer';\n\n        export default myRenderer(withRenderer(withUpdate()));\n        \\`\\`\\`\n\n        > Your renderer can be composed into any point of your mixin chain, too!\n\n        Your component then can use it:\n\n        \\`\\`\\`js\n        // ./my-component.js\n\n        import { props } from 'skatejs';\n        import MyBase from './my-base';\n\n        class MyComponent extends MyBase {\n          static props = {\n            name: props.string\n          };\n          render({ name }) {\n            return \\`Hello, \\${name}!\\`;\n          }\n        }\n        \\`\\`\\`\n      `}\"></x-marked>\n    </x-layout>\n  `;\n});\n\n\n\n// WEBPACK FOOTER //\n// ./pages/renderers/index.js"],"sourceRoot":""}