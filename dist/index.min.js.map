{"version":3,"file":"index.min.js","sources":["../node_modules/object-assign/index.js","../src/native/custom-elements.js","../src/api/create.js","../src/api/symbols.js","../src/util/data.js","../src/lifecycle/attribute-changed.js","../src/api/component.js","../src/util/matches-selector.js","../src/lifecycle/events.js","../node_modules/incremental-dom/src/util.js","../node_modules/incremental-dom/src/node_data.js","../node_modules/incremental-dom/src/symbols.js","../node_modules/incremental-dom/src/attributes.js","../node_modules/incremental-dom/src/nodes.js","../node_modules/incremental-dom/src/notifications.js","../node_modules/incremental-dom/src/context.js","../node_modules/incremental-dom/src/assertions.js","../node_modules/incremental-dom/src/core.js","../node_modules/incremental-dom/src/virtual_elements.js","../node_modules/incremental-dom/index.js","../src/native/support.js","../src/api/vdom.js","../src/lifecycle/render.js","../src/util/dash-case.js","../src/util/get-own-property-descriptors.js","../src/util/protos.js","../src/util/get-all-property-descriptors.js","../src/util/debounce.js","../src/api/emit.js","../src/util/empty.js","../src/lifecycle/props-init.js","../src/api/define.js","../src/api/factory.js","../src/api/state.js","../src/api/link.js","../src/api/prop/array.js","../src/api/prop/boolean.js","../src/api/prop/number.js","../src/api/prop/string.js","../src/api/prop/index.js","../src/api/ready.js","../src/api/version.js","../src/index.js"],"sourcesContent":["'use strict';\n/* eslint-disable no-unused-vars */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (e) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","export default window.customElements;\n","import customElements from '../native/custom-elements';\n\nexport default function (name) {\n  const Ctor = customElements.get(name);\n  return Ctor ? new Ctor() : document.createElement(name);\n}\n","export const events = '____events';\nexport const props = '____props';\nexport const renderer = '____renderer';\nexport const shadowRoot = '____shadowRoot';\n","export default function (element, namespace = '') {\n  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data;\n}\n","import data from '../util/data';\n\nexport default function (Ctor) {\n  const { attributeChanged } = Ctor;\n\n  return function (name, oldValue, newValue) {\n    const propertyName = data(this, 'attributeLinks')[name];\n\n    if (propertyName) {\n      const propData = data(this, `api/property/${propertyName}`);\n\n      // This ensures a property set doesn't cause the attribute changed\n      // handler to run again once we set this flag. This only ever has a\n      // chance to run when you set an attribute, it then sets a property and\n      // then that causes the attribute to be set again.\n      if (propData.syncingAttribute) {\n        propData.syncingAttribute = false;\n        return;\n      }\n\n      // Sync up the property.\n      const propOpts = this.constructor.props[propertyName];\n      propData.settingAttribute = true;\n      this[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n    }\n\n    if (attributeChanged) {\n      attributeChanged(this, { name, newValue, oldValue });\n    }\n  };\n}\n","import * as symbols from './symbols';\nimport data from '../util/data';\n\nexport default class Component extends HTMLElement {\n  constructor () {\n    super();\n\n    const elemData = data(this);\n    const readyCallbacks = elemData.readyCallbacks;\n    const Ctor = this.constructor;\n    const { definedAttribute, events, created, props, ready, renderedAttribute } = this.constructor;\n    const renderer = Ctor[symbols.renderer];\n\n    if (elemData.created) {\n      return;\n    }\n\n    elemData.created = true;\n\n    if (props) {\n      Ctor[symbols.props](this);\n    }\n\n    if (events) {\n      Ctor[symbols.events](this);\n    }\n\n    if (created) {\n      created(this);\n    }\n\n    if (renderer && !this.hasAttribute(renderedAttribute)) {\n      renderer(this);\n    }\n\n    if (ready) {\n      ready(this);\n    }\n\n    if (!this.hasAttribute(definedAttribute)) {\n      this.setAttribute(definedAttribute, '');\n    }\n\n    if (readyCallbacks) {\n      readyCallbacks.forEach(cb => cb(this));\n      delete elemData.readyCallbacks;\n    }\n  }\n}\n\nComponent.definedAttribute = 'defined';\nComponent.events = {};\nComponent.extends = null;\nComponent.observedAttributes = [];\nComponent.props = {};\nComponent.renderedAttribute = 'rendered';\n","const elProto = window.HTMLElement.prototype;\nconst nativeMatchesSelector = (\n  elProto.matches ||\n  elProto.msMatchesSelector ||\n  elProto.webkitMatchesSelector ||\n  elProto.mozMatchesSelector ||\n  elProto.oMatchesSelector\n);\n\n// Only IE9 has this msMatchesSelector bug, but best to detect it.\nconst hasNativeMatchesSelectorDetattachedBug = !nativeMatchesSelector.call(document.createElement('div'), 'div');\n\nexport default function (element, selector) {\n  if (hasNativeMatchesSelectorDetattachedBug) {\n    const clone = element.cloneNode();\n    document.createElement('div').appendChild(clone);\n    return nativeMatchesSelector.call(clone, selector);\n  }\n  return nativeMatchesSelector.call(element, selector);\n}\n","import matches from '../util/matches-selector';\n\nfunction readonly (obj, prop, val) {\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    get () {\n      return val;\n    }\n  });\n}\n\nfunction parseEvent (e) {\n  const indexOfSpace = e.indexOf(' ');\n  const hasSpace = indexOfSpace > 0;\n  const name = hasSpace ? e.substring(0, indexOfSpace) : e;\n  const selector = hasSpace ? e.substring(indexOfSpace + 1) : '';\n  return {\n    name: name,\n    selector: selector\n  };\n}\n\nfunction makeDelegateHandler (elem, handler, parsed) {\n  return function (e) {\n    let current = e.path ? e.path[0] : e.target;\n    const selector = parsed.selector;\n    while (current && current !== elem.parentNode) {\n      if (matches(current, selector)) {\n        readonly(e, 'currentTarget', current);\n        readonly(e, 'delegateTarget', elem);\n        return handler(elem, e);\n      }\n      current = current.parentNode;\n    }\n  };\n}\n\nfunction makeNormalHandler (elem, handler) {\n  return function (e) {\n    readonly(e, 'delegateTarget', elem);\n    handler(elem, e);\n  };\n}\n\nfunction bindEvent (elem, event, handler) {\n  const parsed = parseEvent(event);\n  const { name, selector } = parsed;\n  const capture = selector && (name === 'blur' || name === 'focus');\n  handler = selector ? makeDelegateHandler(elem, handler, parsed) : makeNormalHandler(elem, handler);\n  elem.addEventListener(name, handler, capture);\n}\n\nexport default function events (opts) {\n  const events = opts.events || {};\n  return function (elem) {\n    for (let name in events) {\n      bindEvent(elem, name, events[name]);\n    }\n  };\n}\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A cached reference to the create function.\n */\nconst create = Object.create;\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nconst has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nconst createMap = function() {\n  return create(null);\n};\n\n\n/** */\nexport {\n  createMap,\n  has\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nconst initData = function(node, nodeName, key) {\n  const data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nconst getData = function(node) {\n  let data = node['__incrementalDOMData'];\n\n  if (!data) {\n    const nodeName = node.nodeName.toLowerCase();\n    let key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/** */\nexport {\n  getData,\n  initData\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nconst getNamespace = function(name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nconst applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nconst applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nconst applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n    const obj = /** @type {!Object<string,string>} */(style);\n\n    for (const prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nconst applyAttributeTyped = function(el, name, value) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nconst updateAttribute = function(el, name, value) {\n  const data = getData(el);\n  const attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nconst attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function() {};\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { updateAttribute } from './attributes';\nimport {\n    getData,\n    initData\n} from './node_data';\nimport { createMap } from './util';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nconst getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nconst createElement = function(doc, parent, tag, key, statics) {\n  const namespace = getNamespaceForTag(tag, parent);\n  let el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (let i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nconst createText = function(doc) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nconst createKeyMap = function(el) {\n  const map = createMap();\n  let child = el.firstElementChild;\n\n  while (child) {\n    const key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nconst getKeyMap = function(el) {\n  const data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nconst getChild = function(parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nconst registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\nexport {\n  notifications\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { notifications } from './notifications';\n\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/** */\nexport {\n  Context\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nlet inAttributes = false;\n\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nlet inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n * @param {*} context\n */\nconst assertInPatch = function(context) {\n  if (!context) {\n    throw new Error('Cannot call currentElement() unless in patch.');\n  }\n};\n\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nconst assertKeyedTagMatches = function(nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n        tag + ', not a ' + nodeName + '.');\n  }\n};\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nconst assertNoUnclosedTags = function(openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  let currentElement = openElement;\n  const openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' +\n      openTags.join('\\n'));\n};\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nconst assertNotInAttributes = function(functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nconst assertNotInSkip = function(functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nconst assertInAttributes = function(functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nconst assertVirtualAttributesClosed = function() {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n  * Makes sure that placeholders have a key specified. Otherwise, conditional\n  * placeholders and conditional elements next to placeholders will cause\n  * placeholder elements to be re-used as non-placeholders and vice versa.\n  * @param {string} key\n  */\nconst assertPlaceholderKeySpecified = function(key) {\n  if (!key) {\n    throw new Error('elementPlaceholder() requires a key.');\n  }\n};\n\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nconst assertCloseMatchesOpenTag = function(nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close \"' + tag + '\" but \"' +\n        nodeName + '\" was open.');\n  }\n};\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nconst assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n};\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} node The node requested to be patched.\n * @param {?Node} currentNode The currentNode after the patch.\n */\nconst assertPatchElementNotEmpty = function(node, currentNode) {\n  if (node === currentNode) {\n    throw new Error('There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n};\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} node The node requested to be patched.\n * @param {?Node} previousNode The previousNode after the patch.\n */\nconst assertPatchElementNoExtras = function(node, previousNode) {\n  if (node !== previousNode) {\n    throw new Error('There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n};\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInAttributes = function(value) {\n  const previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInSkip = function(value) {\n  const previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n\n/** */\nexport {\n  assertInPatch,\n  assertKeyedTagMatches,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertPlaceholderKeySpecified,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  assertPatchElementNotEmpty,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createElement,\n  createText,\n  getChild,\n  registerChild\n} from './nodes';\nimport { getData } from './node_data';\nimport { Context } from './context';\nimport { symbols } from './symbols';\nimport {\n  assertInPatch,\n  assertKeyedTagMatches,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertPatchElementNotEmpty,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n} from './assertions';\nimport { notifications } from './notifications';\n\n\n/** @type {?Context} */\nlet context = null;\n\n/** @type {?Node} */\nlet currentNode;\n\n/** @type {?Node} */\nlet currentParent;\n\n/** @type {?Element|?DocumentFragment} */\nlet root;\n\n/** @type {?Document} */\nlet doc;\n\n\n/**\n * Sets up and restores a patch context, running the patch function with the\n * provided data.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     where the patch should start.\n * @param {!function(T)} fn The patching function.\n * @param {T=} data An argument passed to fn.\n * @template T\n */\nconst runPatch = function(node, fn, data) {\n  const prevContext = context;\n  const prevRoot = root;\n  const prevDoc = doc;\n  const prevCurrentNode = currentNode;\n  const prevCurrentParent = currentParent;\n  let previousInAttributes = false;\n  let previousInSkip = false;\n\n  context = new Context();\n  root = node;\n  doc = node.ownerDocument;\n\n  if (process.env.NODE_ENV !== 'production') {\n    previousInAttributes = setInAttributes(false);\n    previousInSkip = setInSkip(false);\n  }\n\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertVirtualAttributesClosed();\n    setInAttributes(previousInAttributes);\n    setInSkip(previousInSkip);\n  }\n\n  context.notifyChanges();\n\n  context = prevContext;\n  root = prevRoot;\n  doc = prevDoc;\n  currentNode = prevCurrentNode;\n  currentParent = prevCurrentParent;\n};\n\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nconst patchInner = function(node, fn, data) {\n  runPatch(node, function(data) {\n    currentNode = node;\n    currentParent = node.parentNode;\n\n    enterNode();\n    fn(data);\n    exitNode();\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertNoUnclosedTags(currentNode, node);\n    }\n  }, data);\n};\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nconst patchOuter = function(node, fn, data) {\n  runPatch(node, function(data) {\n    currentNode = /** @type {!Element} */({ nextSibling: node });\n    currentParent = node.parentNode;\n\n    fn(data);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertPatchElementNotEmpty(node, currentNode.nextSibling);\n      assertPatchElementNoExtras(node, currentNode);\n    }\n  }, data);\n};\n\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nconst matches = function(nodeName, key) {\n  const data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nconst alignWithDOM = function(nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  let node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && process.env.NODE_ENV !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nconst clearUnvisitedDOM = function() {\n  const node = currentParent;\n  const data = getData(node);\n  const keyMap = data.keyMap;\n  const keyMapValid = data.keyMapValid;\n  let child = node.lastChild;\n  let key;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('symbols.placeholder will be removed in Incremental DOM' +\n          ' 0.5 use skip() instead');\n    }\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted(/** @type {!Node}*/(child));\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nconst enterNode = function() {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nconst nextNode = function() {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nconst exitNode = function() {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(currentNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nconst text = function() {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return /** @type {!Text} */(currentNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nconst currentElement = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch(context);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nconst skip = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n\n/** */\nexport {\n  elementOpen,\n  elementClose,\n  text,\n  patchInner,\n  patchOuter,\n  currentElement,\n  skip\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  elementOpen as coreElementOpen,\n  elementClose as coreElementClose,\n  text as coreText,\n  currentElement,\n  skip\n} from './core';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertPlaceholderKeySpecified,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nconst argsBuilder = [];\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(tag, key, statics, const_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = coreElementOpen(tag, key, statics);\n  const data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  const attrsArr = data.attrsArr;\n  const newAttrs = data.newAttrs;\n  let attrsChanged = false;\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (const attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nconst elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nconst attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  const node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementVoid = function(tag, key, statics, const_args) {\n  const node = elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementPlaceholder = function(tag, key, statics, const_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n    console.warn('elementPlaceholder will be removed in Incremental DOM 0.5' +\n        ' use skip() instead');\n  }\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose.apply(null, arguments);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nconst text = function(value, const_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  elementPlaceholder,\n  text,\n  attr\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport {\n  patchInner as patch,\n  patchInner,\n  patchOuter,\n  currentElement,\n  skip\n} from './src/core';\nexport {\n  elementVoid,\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementClose,\n  elementPlaceholder,\n  text,\n  attr\n} from './src/virtual_elements';\nexport { symbols } from './src/symbols';\nexport {\n  attributes,\n  applyAttr,\n  applyProp\n} from './src/attributes';\nexport { notifications } from './src/notifications';\n","const v0 = !!document.registerElement;\nconst v1 = !!window.customElements;\nconst polyfilled = !v0 && !v1;\nconst shadowDomV0 = !!('createShadowRoot' in Element.prototype);\nconst shadowDomV1 = !!('attachShadow' in Element.prototype);\n\nexport default {\n  v0,\n  v1,\n  polyfilled ,\n  shadowDomV0,\n  shadowDomV1\n};\n","import * as IncrementalDOM from 'incremental-dom';\nimport support from '../native/support';\n\n// Could import these, but we have to import all of IncrementalDOM anyways so\n// that we can export our configured IncrementalDOM.\nconst {\n  applyProp,\n  attr,\n  attributes,\n  elementClose,\n  elementOpen,\n  elementOpenEnd,\n  elementOpenStart,\n  skip,\n  symbols,\n  text\n} = IncrementalDOM;\n\n// Specify an environment for iDOM in case we haven't yet.\nif (typeof process === 'undefined') {\n  /* eslint no-undef: 0 */\n  process = { env: { NODE_ENV: 'production' } };\n}\n\nconst applyDefault = attributes[symbols.default];\nconst factories = {};\n\n// Attributes that are not handled by Incremental DOM.\nattributes.key = attributes.skip = attributes.statics = function () {};\n\n// Attributes that *must* be set via a property on all elements.\nattributes.checked = attributes.className = attributes.disabled = attributes.value = applyProp;\n\n// Default attribute applicator.\nattributes[symbols.default] = function (elem, name, value) {\n  // Boolean false values should not set attributes at all.\n  if (value === false) {\n    return;\n  }\n\n  // Custom element properties should be set as properties.\n  const props = elem.constructor.props;\n  if (props && name in props) {\n    return applyProp(elem, name, value);\n  }\n\n  // Handle built-in and custom events.\n  if (name.indexOf('on') === 0) {\n    return name in elem ? applyProp(elem, name, value) : applyEvent(elem, name.substring(2), name, value);\n  }\n\n  // Fallback to default IncrementalDOM behaviour.\n  applyDefault(elem, name, value);\n};\n\n// Adds or removes an event listener for an element.\nfunction applyEvent (elem, ename, name, value) {\n  let events = elem.__events;\n\n  if (!events) {\n    events = elem.__events = {};\n  }\n\n  const eFunc = events[ename];\n\n  // Remove old listener so they don't double up.\n  if (eFunc) {\n    elem.removeEventListener(ename, eFunc);\n  }\n\n  // Bind new listener.\n  if (value) {\n    elem.addEventListener(ename, events[ename] = function (e) {\n      if (this === e.target) {\n        value.call(this, e);\n      }\n    });\n  }\n}\n\n// Creates a factory and returns it.\nfunction bind (tname) {\n  const shouldBeContentTag = tname === 'slot' && !support.shadowDomV1 && support.shadowDomV0;\n\n  // Abstract Shadow DOM V0 <content> behind Shadow DOM V1 <slot>.\n  if (shouldBeContentTag) {\n    tname = 'content';\n  }\n\n  return factories[tname] = function (attrs, chren) {\n    if (attrs && typeof attrs === 'object') {\n      // Abstract Shadow DOM V0 <content> behind Shadow DOM V1 <slot>.\n      if (shouldBeContentTag && attrs.name) {\n        attrs.select = `[slot=\"${attrs.name}\"]`;\n        delete attrs.slot;\n      }\n\n      elementOpenStart(tname, attrs.key, attrs.statics);\n      for (let a in attrs) {\n        attr(a, attrs[a]);\n      }\n      elementOpenEnd();\n    } else {\n      elementOpen(tname);\n      chren = attrs;\n      attrs = {};\n    }\n\n    if (attrs.skip) {\n      skip();\n    } else {\n      const chrenType = typeof chren;\n      if (chrenType === 'function') {\n        chren();\n      } else if (chrenType === 'string' || chrenType === 'number') {\n        text(chren);\n      }\n    }\n\n    return elementClose(tname);\n  };\n}\n\n// The default function requries a tag name.\nexport default function create (tname, attrs, chren) {\n  // Allow a component constructor to be passed in.\n  if (typeof tname === 'function') {\n    tname = tname.id || tname.name;\n  }\n  // Return the cached factory or create a new one and return it.\n  return (factories[tname] || bind(tname))(attrs, chren);\n}\n\n// Export the Incremental DOM text() function directly as we don't need to do\n// any special processing for it.\nexport { text };\n\n// We export IncrementalDOM in its entirety because we want the user to be able\n// to user our configured version while still being able to use various other\n// templating languages and techniques that compile down to it.\nexport { IncrementalDOM };\n\n// Create factories for all HTML elements except for ones that match keywords\n// such as \"var\".\nexport const a = bind('a');\nexport const abbr = bind('abbr');\nexport const address = bind('address');\nexport const area = bind('area');\nexport const article = bind('article');\nexport const aside = bind('aside');\nexport const audio = bind('audio');\nexport const b = bind('b');\nexport const base = bind('base');\nexport const bdi = bind('bdi');\nexport const bdo = bind('bdo');\nexport const bgsound = bind('bgsound');\nexport const blockquote = bind('blockquote');\nexport const body = bind('body');\nexport const br = bind('br');\nexport const button = bind('button');\nexport const canvas = bind('canvas');\nexport const caption = bind('caption');\nexport const cite = bind('cite');\nexport const code = bind('code');\nexport const col = bind('col');\nexport const colgroup = bind('colgroup');\nexport const command = bind('command');\nexport const content = bind('content');\nexport const data = bind('data');\nexport const datalist = bind('datalist');\nexport const dd = bind('dd');\nexport const del = bind('del');\nexport const details = bind('details');\nexport const dfn = bind('dfn');\nexport const dialog = bind('dialog');\nexport const div = bind('div');\nexport const dl = bind('dl');\nexport const dt = bind('dt');\nexport const element = bind('element');\nexport const em = bind('em');\nexport const embed = bind('embed');\nexport const fieldset = bind('fieldset');\nexport const figcaption = bind('figcaption');\nexport const figure = bind('figure');\nexport const font = bind('font');\nexport const footer = bind('footer');\nexport const form = bind('form');\nexport const h1 = bind('h1');\nexport const h2 = bind('h2');\nexport const h3 = bind('h3');\nexport const h4 = bind('h4');\nexport const h5 = bind('h5');\nexport const h6 = bind('h6');\nexport const head = bind('head');\nexport const header = bind('header');\nexport const hgroup = bind('hgroup');\nexport const hr = bind('hr');\nexport const html = bind('html');\nexport const i = bind('i');\nexport const iframe = bind('iframe');\nexport const image = bind('image');\nexport const img = bind('img');\nexport const input = bind('input');\nexport const ins = bind('ins');\nexport const kbd = bind('kbd');\nexport const keygen = bind('keygen');\nexport const label = bind('label');\nexport const legend = bind('legend');\nexport const li = bind('li');\nexport const link = bind('link');\nexport const main = bind('main');\nexport const map = bind('map');\nexport const mark = bind('mark');\nexport const marquee = bind('marquee');\nexport const menu = bind('menu');\nexport const menuitem = bind('menuitem');\nexport const meta = bind('meta');\nexport const meter = bind('meter');\nexport const multicol = bind('multicol');\nexport const nav = bind('nav');\nexport const nobr = bind('nobr');\nexport const noembed = bind('noembed');\nexport const noframes = bind('noframes');\nexport const noscript = bind('noscript');\nexport const object = bind('object');\nexport const ol = bind('ol');\nexport const optgroup = bind('optgroup');\nexport const option = bind('option');\nexport const output = bind('output');\nexport const p = bind('p');\nexport const param = bind('param');\nexport const picture = bind('picture');\nexport const pre = bind('pre');\nexport const progress = bind('progress');\nexport const q = bind('q');\nexport const rp = bind('rp');\nexport const rt = bind('rt');\nexport const rtc = bind('rtc');\nexport const ruby = bind('ruby');\nexport const s = bind('s');\nexport const samp = bind('samp');\nexport const script = bind('script');\nexport const section = bind('section');\nexport const select = bind('select');\nexport const shadow = bind('shadow');\nexport const slot = bind('slot');\nexport const small = bind('small');\nexport const source = bind('source');\nexport const span = bind('span');\nexport const strong = bind('strong');\nexport const style = bind('style');\nexport const sub = bind('sub');\nexport const summary = bind('summary');\nexport const sup = bind('sup');\nexport const table = bind('table');\nexport const tbody = bind('tbody');\nexport const td = bind('td');\nexport const template = bind('template');\nexport const textarea = bind('textarea');\nexport const tfoot = bind('tfoot');\nexport const th = bind('th');\nexport const thead = bind('thead');\nexport const time = bind('time');\nexport const title = bind('title');\nexport const tr = bind('tr');\nexport const track = bind('track');\nexport const u = bind('u');\nexport const ul = bind('ul');\nexport const video = bind('video');\nexport const wbr = bind('wbr');\n","import { IncrementalDOM } from '../api/vdom';\nimport { shadowRoot } from '../api/symbols';\n\nconst { patch } = IncrementalDOM;\n\nexport default function (Ctor) {\n  const { render } = Ctor;\n\n  return function (elem) {\n    if (!render) {\n      return;\n    }\n\n    if (!elem[shadowRoot]) {\n      let sr;\n\n      if (elem.attachShadow) {\n        sr = elem.attachShadow({ mode: 'open' });\n      } else if (elem.createShadowRoot) {\n        sr = elem.createShadowRoot();\n      } else {\n        sr = elem;\n      }\n\n      elem[shadowRoot] = sr;\n    }\n\n    patch(elem[shadowRoot], render, elem);\n  };\n}\n","export default function (str) {\n  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    return `${one}${dash}${two.toLowerCase()}`;\n  });\n}\n","export default function (obj) {\n  return Object.getOwnPropertyNames(obj || {}).reduce(function (prev, curr) {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n}","export default function (proto) {\n  var chains = [];\n  while (proto) {\n    chains.push(proto);\n    proto = Object.getPrototypeOf(proto);\n  }\n  chains.reverse();\n  return chains;\n}\n","import getOwnPropertyDescriptors from './get-own-property-descriptors';\nimport protos from './protos';\n\nexport default function (obj) {\n  return protos(obj|| {}).reduce(function (result, proto) {\n    const descriptors = getOwnPropertyDescriptors(proto);\n    Object.getOwnPropertyNames(descriptors).reduce(function (result, name) {\n      result[name] = descriptors[name];\n      return result;\n    }, result);\n    return result;\n  }, {});\n}\n","const raf = window.requestAnimationFrame || setTimeout;\nexport default function (fn) {\n  var called = false;\n\n  return function (...args) {\n    if (!called) {\n      called = true;\n      raf(() => {\n        called = false;\n        fn.apply(this, args);\n      });\n    }\n  };\n}\n","const CustomEvent = (function (CustomEvent) {\n  if (CustomEvent) {\n    try {\n      new CustomEvent();\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return CustomEvent;\n}(window.CustomEvent));\n\nfunction createCustomEvent (name, opts = {}) {\n  if (CustomEvent) {\n    return new CustomEvent(name, opts);\n  }\n  const e = document.createEvent('CustomEvent');\n  e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n  return e;\n}\n\nexport default function (elem, name, opts = {}) {\n  /* jshint expr: true */\n  opts.bubbles === undefined && (opts.bubbles = true);\n  opts.cancelable === undefined && (opts.cancelable = true);\n  return elem.disabled ? true : elem.dispatchEvent(createCustomEvent(name, opts));\n}\n","export default function (val) {\n  return typeof val === 'undefined' || val === null;\n}","import * as symbols from '../api/symbols';\nimport assign from 'object-assign';\nimport data from '../util/data';\nimport debounce from '../util/debounce';\nimport emit from '../api/emit';\nimport empty from '../util/empty';\n\n// Symbol() wasn't transpiling properly.\nconst $debounce = '____debouncedRender';\n\nfunction getDefaultValue (elem, name, opts) {\n  return typeof opts.default === 'function' ? opts.default(elem, { name }) : opts.default;\n}\n\nfunction getInitialValue (elem, name, opts) {\n  return typeof opts.initial === 'function' ? opts.initial(elem, { name }) : opts.initial;\n}\n\nfunction createNativePropertyDefinition (name, opts) {\n  const prop = {\n    configurable: true,\n    enumerable: true\n  };\n\n  prop.created = function (elem) {\n    const propData = data(elem, `api/property/${name}`);\n    const attributeName = opts.attribute;\n    let initialValue = elem[name];\n    let shouldSyncAttribute = false;\n\n    // Store property to attribute link information.\n    data(elem, 'attributeLinks')[attributeName] = name;\n    data(elem, 'propertyLinks')[name] = attributeName;\n\n    // Set up initial value if it wasn't specified.\n    if (empty(initialValue)) {\n      if (attributeName && elem.hasAttribute(attributeName)) {\n        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n      } else if ('initial' in opts) {\n        initialValue = getInitialValue(elem, name, opts);\n        shouldSyncAttribute = true;\n      } else if ('default' in opts) {\n        initialValue = getDefaultValue(elem, name, opts);\n      }\n    }\n\n    if (shouldSyncAttribute) {\n      prop.set.call(elem, initialValue);\n    } else {\n      propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n    }\n  };\n\n  prop.get = function () {\n    const propData = data(this, `api/property/${name}`);\n    const { internalValue } = propData;\n    if (typeof opts.get === 'function') {\n      return opts.get(this, { name, internalValue });\n    }\n    return internalValue;\n  };\n\n  prop.render = (function () {\n    const shouldUpdate = opts.render;\n    if (typeof shouldUpdate === 'undefined') {\n      return function (elem, data) {\n        return data.newValue !== data.oldValue;\n      };\n    }\n    if (typeof shouldUpdate === 'function') {\n      return shouldUpdate;\n    }\n    return function () {\n      return !!shouldUpdate;\n    };\n  }());\n\n  prop.set = function (newValue) {\n    const propData = data(this, `api/property/${name}`);\n    let { oldValue } = propData;\n    let shouldRemoveAttribute = false;\n\n    if (empty(oldValue)) {\n      oldValue = null;\n    }\n\n    if (empty(newValue)) {\n      newValue = getDefaultValue(this, name, opts);\n      shouldRemoveAttribute = true;\n    }\n\n    if (typeof opts.coerce === 'function') {\n      newValue = opts.coerce(newValue);\n    }\n\n    const propertyHasChanged = newValue !== oldValue;\n    if (propertyHasChanged && opts.event) {\n      const canceled = !emit(this, String(opts.event), {\n        bubbles: false,\n        detail: { name, oldValue, newValue }\n      });\n\n      if (canceled) {\n        return;\n      }\n    }\n\n    propData.internalValue = newValue;\n\n    const changeData = { name, newValue, oldValue };\n\n    if (typeof opts.set === 'function') {\n      opts.set(this, changeData);\n    }\n\n    // Re-render on property updates if the should-update check passes.\n    if (prop.render(this, changeData)) {\n      const deb = this[$debounce] || (this[$debounce] = debounce(this.constructor[symbols.renderer]));\n      deb(this);\n    }\n\n    propData.oldValue = newValue;\n\n    // Link up the attribute.\n    const attributeName = data(this, 'propertyLinks')[name];\n    if (attributeName && !propData.settingAttribute) {\n      const serializedValue = opts.serialize(newValue);\n      propData.syncingAttribute = true;\n      if (shouldRemoveAttribute || empty(serializedValue)) {\n        this.removeAttribute(attributeName);\n      } else {\n        this.setAttribute(attributeName, serializedValue);\n      }\n    }\n\n    // Allow the attribute to be linked again.\n    propData.settingAttribute = false;\n  };\n\n  return prop;\n}\n\nexport default function (opts) {\n  opts = opts || {};\n\n  if (typeof opts === 'function') {\n    opts = { coerce: opts };\n  }\n\n  return function (name) {\n    return createNativePropertyDefinition(name, assign({\n      default: null,\n      deserialize: value => value,\n      serialize: value => value\n    }, opts));\n  };\n}\n","import * as symbols from './symbols';\nimport attributeChanged from '../lifecycle/attribute-changed';\nimport Component from './component';\nimport createInitEvents from '../lifecycle/events';\nimport createRenderer from '../lifecycle/render';\nimport dashCase from '../util/dash-case';\nimport getAllPropertyDescriptors from '../util/get-all-property-descriptors';\nimport getOwnPropertyDescriptors from '../util/get-own-property-descriptors';\nimport initProps from '../lifecycle/props-init';\n\n// Ensures that definitions passed as part of the constructor are functions\n// that return property definitions used on the element.\nfunction ensurePropertyFunctions (Ctor) {\n  let props = Ctor.props;\n  let names = Object.keys(props || {});\n  return names.reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = props[descriptorName];\n    if (typeof descriptors[descriptorName] !== 'function') {\n      descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n    }\n    return descriptors;\n  }, {});\n}\n\n// Ensures the property definitions are transformed to objects that can be used\n// to create properties on the element.\nfunction ensurePropertyDefinitions (Ctor) {\n  const props = ensurePropertyFunctions(Ctor);\n  return Object.keys(props).reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = props[descriptorName](descriptorName);\n    return descriptors;\n  }, {});\n}\n\n// Makes a function / constructor for the custom element that automates the\n// boilerplate of ensuring the parent constructor is called first and ensures\n// that the element is returned at the end.\nfunction createConstructor (name, Ctor) {\n  if (typeof Ctor === 'object') {\n    const opts = getAllPropertyDescriptors(Ctor);\n    const prot = getOwnPropertyDescriptors(Ctor.prototype);\n\n    // The prototype is non-configurable, so we remove it before it tries to\n    // define it.\n    delete opts.prototype;\n\n    Ctor = class extends Component {};\n\n    Object.defineProperties(Ctor, opts);\n    Object.defineProperties(Ctor.prototype, prot);\n  }\n\n  Ctor.prototype.attributeChangedCallback = attributeChanged(Ctor);\n  Ctor.prototype.connectedCallback = function () { Ctor.attached && Ctor.attached(this); };\n  Ctor.prototype.disconnectedCallback = function () { Ctor.detached && Ctor.detached(this); };\n\n  // WebKit currently doesn't allow you to overwrite \"name\" so we have to use\n  // \"id\" for cross-browser compat right now.\n  Object.defineProperty(Ctor, 'id', { value: name });\n\n  // We do set \"name\" in browsers that support it, though.\n  if (Object.getOwnPropertyDescriptor(Ctor, 'name').configurable) {\n    Object.defineProperty(Ctor, 'name', { value: name });\n  }\n\n  return Ctor;\n}\n\n// Ensures linked properties that have linked attributes are pre-formatted to\n// the attribute name in which they are linked.\nfunction formatLinkedAttributes (Ctor) {\n  const { observedAttributes, props } = Ctor;\n\n  if (!props) {\n    return;\n  }\n\n  Object.keys(props).forEach(function (name) {\n    const prop = props[name];\n    const attr = prop.attribute;\n    if (attr) {\n      // Ensure the property is updated.\n      const linkedAttr = prop.attribute = attr === true ? dashCase(name) : attr;\n\n      // Automatically observe the attribute since they're linked from the\n      // attributeChangedCallback.\n      if (observedAttributes.indexOf(linkedAttr) === -1) {\n        observedAttributes.push(linkedAttr);\n      }\n    }\n  });\n\n  Ctor.observedAttributes = observedAttributes;\n}\n\nfunction createInitProps (Ctor) {\n  const props = ensurePropertyDefinitions(Ctor);\n\n  return function (elem) {\n    if (!props) {\n      return;\n    }\n\n    Object.keys(props).forEach(function (name) {\n      const prop = props[name];\n      prop.created(elem);\n\n      // https://bugs.webkit.org/show_bug.cgi?id=49739\n      //\n      // When Webkit fixes that bug so that native property accessors can be\n      // retrieved, we can move defining the property to the prototype and away\n      // from having to do if for every instance as all other browsers support\n      // this.\n      Object.defineProperty(elem, name, prop);\n    });\n  };\n}\n\nexport default function (name, Ctor) {\n  Ctor = createConstructor(name, Ctor);\n  formatLinkedAttributes(Ctor);\n  Ctor[symbols.events] = createInitEvents(Ctor);\n  Ctor[symbols.props] = createInitProps(Ctor);\n  Ctor[symbols.renderer] = createRenderer(Ctor);\n  window.customElements.define(name, Ctor);\n  return window.customElements.get(name);\n}\n","import define from './define';\n\nexport default function (opts) {\n  return function (name) {\n    return define(name, opts);\n  };\n}\n","import { renderer } from './symbols';\nimport assign from 'object-assign';\n\nfunction get (elem) {\n  const props = elem.constructor.props;\n  const state = {};\n  for (let key in props) {\n    const val = elem[key];\n    if (typeof val !== 'undefined') {\n      state[key] = val;\n    }\n  }\n  return state;\n}\n\nfunction set (elem, newState) {\n  assign(elem, newState);\n  if (elem.constructor.render) {\n    elem.constructor[renderer](elem);\n  }\n}\n\nexport default function (elem, newState) {\n  return typeof newState === 'undefined' ? get(elem) : set(elem, newState);\n}\n","import state from './state';\n\nfunction getValue (elem) {\n  const type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nexport default function (elem, target) {\n  return function (e) {\n    const value = getValue(e.target);\n    const localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      const parts = localTarget.split('.');\n      const firstPart = parts[0];\n      const propName = parts.pop();\n      const obj = parts.reduce(function (prev, curr) {\n        return prev && prev[curr];\n      }, elem);\n\n      obj[propName || e.target.name] = value;\n      state(elem, {\n        [firstPart]: elem[firstPart]\n      });\n    } else {\n      state(elem, {\n        [localTarget]: value\n      });\n    }\n  };\n}\n","export default {\n  coerce: val => Array.isArray(val) ? val : [val],\n  default: () => [],\n  deserialize: JSON.parse,\n  serialize: JSON.stringify\n};\n","export default {\n  coerce: value => !!value,\n  default: false,\n  deserialize: value => !(value === null),\n  serialize: value => value ? '' : undefined\n};\n","import empty from '../../util/empty';\n\nconst alwaysUndefinedIfEmpty = val => empty(val) ? undefined : Number(val);\n\nexport default {\n  coerce: alwaysUndefinedIfEmpty,\n  deserialize: alwaysUndefinedIfEmpty,\n  serialize: alwaysUndefinedIfEmpty\n};\n","import empty from '../../util/empty';\n\nconst alwaysUndefinedIfEmpty = val => empty(val) ? undefined : String(val);\n\nexport default {\n  coerce: alwaysUndefinedIfEmpty,\n  deserialize: alwaysUndefinedIfEmpty,\n  serialize: alwaysUndefinedIfEmpty\n};\n","import assign from 'object-assign';\nimport propArray from './array';\nimport propBoolean from './boolean';\nimport propNumber from './number';\nimport propString from './string';\n\nexport default function prop (def) {\n  return function (...args) {\n    args.unshift({}, def);\n    return assign.apply(null, args);\n  };\n}\n\nexport const array = prop(propArray);\nexport const boolean = prop(propBoolean);\nexport const number = prop(propNumber);\nexport const string = prop(propString);\n","import data from '../util/data';\n\nexport default function (elem, done) {\n  const info = data(elem);\n  if (info.created) {\n    done(elem);\n  } else if (info.readyCallbacks) {\n    info.readyCallbacks.push(done);\n  } else {\n    info.readyCallbacks = [done];\n  }\n}\n","export default '0.15.3';\n","import assign from 'object-assign';\n\n// Public API\nimport create from './api/create';\nimport define from './api/define';\nimport emit from './api/emit';\nimport factory from './api/factory';\nimport link from './api/link';\nimport prop, * as props from './api/prop';\nimport ready from './api/ready';\nimport state from './api/state';\nimport * as symbols from './api/symbols';\nimport vdom, * as vdomElements from './api/vdom';\nimport version from './api/version';\n\nassign(prop, props);\nassign(vdom, vdomElements);\n\nexport default define;\nexport {\n  create,\n  define,\n  emit,\n  factory,\n  link,\n  prop,\n  ready,\n  state,\n  symbols,\n  vdom,\n  version\n};\n"],"names":["name","Ctor","customElements","get","document","createElement","namespace","data","attributeChanged","e","current","makeNormalHandler","parsed","selector","capture","newAttrs","events","chren","chrenType","tname","elem","idx","Object","obj","descriptors","_len","arguments","fn","args","propData","attributeName","internalValue","this","empty","set","serialize","serializedValue","ensurePropertyFunctions","props","names","descriptorName","defineProperties","detached","alwaysUndefinedIfEmpty","toObject","val","undefined","TypeError","shouldUseNative","assign","test1","String","getOwnPropertyNames","test2","i","fromCharCode","order2","map","n","join","test3","split","forEach","letter","keys","hasOwnProperty","prototype","propIsEnumerable","propertyIsEnumerable","module","exports","target","source","from","symbols","to","s","length","key","call","getOwnPropertySymbols","window","renderer","shadowRoot","babelHelpers","readyCallbacks","created","Component","property","node","nodeName","style","createElementNS","push","Context","inAttributes","openTags","setInSkip","previousInAttributes","process","env","NODE_ENV","currentNode","getChild","getData","child","firstChild","ATTRIBUTES_OFFSET","j","tag","coreText","patchInner","skip","v1","Element","support","text$1","attributes","statics","applyProp","a","abbr","address","area","article","bind","aside","audio","b","base","bdi","bdo","bgsound","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","command","content","data$1","datalist","dd","del","details","dfn","dialog","div","dl","dt","element","em","embed","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","iframe","image","img","input","ins","kbd","keygen","label","legend","li","link","main","mark","marquee","menu","menuitem","meta","meter","multicol","nav","nobr","noembed","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","rtc","ruby","samp","script","select","IncrementalDOM","CustomEvent"],"mappings":"8PEEyBA,MACjBC,GAAOC,EAAeC,IAAIH,SACzBC,GAAO,GAAIA,GAASG,SAASC,cAAcL,oBGD1CM,0GAEDA,KAAAC,OAAAA,aAGL,sBACmBC,6TEUtB,yEChBC,uDAMD,4EAIO,YAKJ,oEAIJC,8CAOQ,qLAUQC,eAKhB,QAASC,6BAEoBF,8BAG3B,wCAGaG,EAAuBC,mFAIVC,GAG3B,sIERMC,mMWkCDC,uJAwBA,gQAiBA,mDAmBO,oBAEO,0BACbC,6BACc,+BAEdC,uBAKM,cAKN,wBAEA,uBACMC,mCSnHP,oKAgBOC,wBAUV,wEAEoBC,sIAMNC,4CAKX,wFAUE,uBACQC,+BAFVC,qHAcS,mCAKFC,EAAOC,sFAQVC,UAAgBC,qNAyBjBnB,EAGH,8PCxIF,qEACuDW,yBAGvD,2KAQFS,sDASOT,oBAAyBU,6KASTD,EAArBE,qWAyB0BxB,EADSyB,yDAS7BC,2PAyBJ,4BACKC,yKAcsBC,uFAK/BC,4BExHA,6BAGc,gHAUVD,sCCfN,QAASE,SACDC,WACFC,mHAYA,WAActC,iCAEGqC,iCACLE,kBAYb,mIC7BY,iKCDIvC,0CAEGwC,iBAATxC,qLCDuByC,4HCAhCC,4CAES,2CCEe1C,EAAKqC,oKCKlC,imExCXD,YAKA,SAASM,GAASC,MACL,OAARA,GAAwBC,SAARD,OACb,IAAIE,WAAU,+DAGdzB,QAAOuB,GAGf,QAASG,aAEF1B,OAAO2B,cACJ,KAMJC,GAAQ,GAAIC,QAAO,YACjB,GAAK,KACkC,MAAzC7B,OAAO8B,oBAAoBF,GAAO,UAC9B,MAKH,GADDG,MACKC,EAAI,EAAO,GAAJA,EAAQA,MACjB,IAAMH,OAAOI,aAAaD,IAAMA,KAEnCE,GAASlC,OAAO8B,oBAAoBC,GAAOI,IAAI,SAAUC,SACrDL,GAAMK,QAEU,eAApBF,EAAOG,KAAK,WACR,KAIJC,mCACmBC,MAAM,IAAIC,QAAQ,SAAUC,KAC5CA,GAAUA,IAGf,yBADEzC,OAAO0C,KAAK1C,OAAO2B,UAAWW,IAAQD,KAAK,IAM9C,MAAOlD,UAED,GAnDT,GAAIwD,GAAiB3C,OAAO4C,UAAUD,eAClCE,EAAmB7C,OAAO4C,UAAUE,oBAsDxCC,GAAOC,QAAUtB,IAAoB1B,OAAO2B,OAAS,SAAUsB,EAAQC,OAKjE,GAJDC,GAEAC,EADAC,EAAK/B,EAAS2B,GAGTK,EAAI,EAAGA,EAAIlD,UAAUmD,OAAQD,IAAK,GACnCtD,OAAOI,UAAUkD,QAEnB,GAAIE,KAAOL,GACXR,EAAec,KAAKN,EAAMK,OAC1BA,GAAOL,EAAKK,OAIbxD,OAAO0D,sBAAuB,GACvB1D,OAAO0D,sBAAsBP,OAClC,GAAInB,GAAI,EAAGA,EAAIoB,EAAQG,OAAQvB,IAC/Ba,EAAiBY,KAAKN,EAAMC,EAAQpB,QACpCoB,EAAQpB,IAAMmB,EAAKC,EAAQpB,YAM3BqB,8DCjFOM,OAAO/E,eEATc,EAAS,aACTsB,EAAQ,YACR4C,EAAW,eACXC,EAAa,oIGOInE,GANboE,sEAM8B9C,OAAO+C,IAAAA,eAAOpF,gCACnDiF,gCAEFI,+UCbRC,8BACAA,sDASAA,yCAGE,sRE+BgBC,sHC8DdC,+CAIOC,8eEvBIC,mBACLA,oOAyCFpF,WACMA,aAEZP,iIC/FC,gLA4BD4F,0dE1CF,qEA0BAC,wEAUAA,SAOGC,2KCpCH,IAAIC,uNAwCuB,yJAcGC,iQAmCxB,swBC9EFC,uIAqCEC,2CAOyB,eAAzBC,QAAQC,IAAIC,mRA2D6B9F,4NA2CzC+F,iCAQJC,SACMd,8BAAJY,aACEG,0MAuCAf,yCAIAgB,gHASFJ,4QA4BE9F,wFAqBWmG,4ZCzPXC,yIAqCWpG,sCAMR+C,EAAI5B,UAAUmD,OAAQvB,GAAK,EAAGsD,GAAK,gHAa/B/B,YAMP,6JA8BQuB,yJA+BS,wIAkBrBS,gcA2Ea,iFAMFC,mJEzQEC,iDAAfC,sOCaIC,KAAOhC,OAAP/E,iCAEiB,oBAAFgH,8DAGbC,sHAmBKC,EAIL,oBAAKjB,iDAKT,QAAAkB,uBAIFA,mBAA+CC,qBAG7CD,wIAYAE,uFAqGK,IAAMC,WACAC,aACAC,gBACAC,aACAC,GAAUC,EAAhB,WACMC,cACAC,cACAC,UACAC,aACAC,KAAW,OACXC,YACAC,gBACAC,KAAO,cACPC,aACAC,WACAC,KAAK,UACLC,KAAK,UACLC,GAAUb,EAAhB,WACMc,aACAC,aACAC,YACAC,iBACAC,gBACAC,gBACAC,KAAK,QACLC,iBACAC,WACAC,YACAC,gBACAC,GAAMzB,EAAK,OACX0B,eACAC,GAAM3B,EAAK,OACX4B,WACAC,WACAC,gBACAC,WACAC,cACAC,iBACAC,KAAO,cACPC,eACAC,GAAOpC,EAAK,QACZqC,eACAC,GAAOtC,EAAK,QACZuC,WACAC,WACAC,WACAC,WACAC,WACAC,WACAC,aACAC,eACAC,eACAC,WACAC,aACAxH,UACAyH,GAASlD,EAAK,UACdmD,cACAC,YACAC,GAAQrD,EAAK,SACbsD,YACAC,GAAMvD,EAAK,OACXwD,eACAC,KAAN,SACMC,KAAK,UACLC,GAAK3D,EAAK,MACV4D,aACAC,GAAO7D,EAAK,QACZpE,YACAkI,GAAO9D,EAAK,QACZ+D,gBACAC,aACAC,iBACAC,aACAC,cACAC,iBACAC,YACAC,GAAOtE,EAAK,QACZuE,gBACAC,iBACAC,GAAWzE,EAAL,YACN0E,eACAC,WACAC,iBACAC,eACAC,KAAK,UACLC,UACAC,cACAC,gBACAC,YACAC,iBACAC,UACAC,WACAC,GAAKtF,EAAK,MACVuF,YACAC,KAAI,QACJzI,UACA0I,aACAC,+BC1QLC,uHAMJ,8FAOW3F,uEAKP,wEAMEA,EAAK,4DC1BN4F,6DCAA1F,oBAAAG,8IEICe,yFCHJW,+DAEsBM,+JCInBoB,GACPC,uDAISK,qCAIFI,4HChBAa,4bC0IAa"}