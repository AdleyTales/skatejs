{"version":3,"file":"index.min.js","sources":["../node_modules/object-assign/index.js","../src/native/custom-elements.js","../src/util/element-contains.js","../src/util/find-element-in-registry.js","../src/native/support.js","../src/util/ignored.js","../src/util/walk-tree.js","../src/api/init.js","../src/api/create.js","../src/api/emit.js","../src/util/data.js","../src/lifecycle/attached.js","../src/lifecycle/attribute-changed.js","../src/util/matches-selector.js","../src/lifecycle/events.js","../src/lifecycle/patch-attribute-methods.js","../src/util/debounce.js","../src/util/empty.js","../src/lifecycle/properties-init.js","../src/util/protos.js","../src/util/define-properties.js","../src/util/get-own-property-descriptors.js","../src/lifecycle/prototype.js","../src/lifecycle/created.js","../src/util/dash-case.js","../src/data.js","../src/defaults.js","../src/lifecycle/detached.js","../src/fix/ie/innerhtml.js","../src/util/get-closest-ignored-element.js","../src/native/document-observer.js","../node_modules/incremental-dom/dist/incremental-dom-cjs.js","../src/api/vdom.js","../src/lifecycle/render.js","../src/util/get-all-property-descriptors.js","../src/api/skate.js","../src/api/factory.js","../src/api/fragment.js","../src/api/state.js","../src/api/link.js","../src/api/prop/array.js","../src/api/prop/boolean.js","../src/api/prop/number.js","../src/api/prop/string.js","../src/api/prop/index.js","../src/api/ready.js","../src/api/version.js","../src/index.js"],"sourcesContent":["'use strict';\n/* eslint-disable no-unused-vars */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (e) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","const reservedNames = [\n  'annotation-xml',\n  'color-profile',\n  'font-face',\n  'font-face-src',\n  'font-face-uri',\n  'font-face-format',\n  'font-face-name',\n  'missing-glyph'\n];\nconst customElementCriteria = [\n  'contain at least one dash',\n  'not start with a dash',\n  `not be one of: ${reservedNames.join(', ')}`\n];\nconst definitions = {};\n\nexport default window.customElements || {\n  define (name, Ctor) {\n    if (definitions[name]) {\n      throw new Error(`A Skate component with the name of \"${name}\" already exists.`);\n    }\n\n    // Screen non-native names and try and be more helpful than native.\n    if (name.indexOf('-') < 1 || reservedNames.indexOf(name) > -1) {\n      throw new Error(`${name} is not a valid custom element name. A custom element name must: ${customElementCriteria.map(a => `\\n- ${a}`).join('')}`);\n    }\n\n    // Support legacy Blink.\n    if (document.registerElement) {\n      // Blink is picky about options.\n      const nativeDefinition = { prototype: Ctor.prototype };\n\n      // Only set extends if the user specified it otherwise Blink complains\n      // even if it's null.\n      if (Ctor.extends) {\n        nativeDefinition.extends = Ctor.extends;\n      }\n\n      document.registerElement(name, nativeDefinition);\n    }\n\n    // Actually register.\n    definitions[name] = Ctor;\n  },\n  get (name) {\n    return definitions[name];\n  }\n};\n","const { body, head } = document;\nconst elementPrototype = window.HTMLElement.prototype;\nconst elementPrototypeContains = elementPrototype.contains;\n\nexport default function (source, target) {\n  // The document element does not have the contains method in IE.\n  if (source === document && !source.contains) {\n    return head.contains(target) || body.contains(target);\n  }\n  return source.contains ? source.contains(target) : elementPrototypeContains.call(source, target);\n}\n","import customElements from '../native/custom-elements';\n\nexport default function (elem) {\n  const tagName = elem.tagName;\n\n  if (!tagName) {\n    return;\n  }\n\n  const tagNameLc = tagName.toLowerCase();\n  const tagNameDefinition = customElements.get(tagNameLc);\n\n  if (tagNameDefinition) {\n    return tagNameDefinition;\n  }\n\n  const isAttribute = elem.getAttribute('is');\n  const isAttributeDefinition = customElements.get(isAttribute);\n\n  if (isAttributeDefinition && isAttributeDefinition.extends === tagNameLc) {\n    return isAttributeDefinition;\n  }\n}\n","const v0 = !!document.registerElement;\nconst v1 = !!window.customElements;\nconst polyfilled = !v0 && !v1;\nconst shadowDomV0 = !!('createShadowRoot' in Element.prototype);\nconst shadowDomV1 = !!('attachShadow' in Element.prototype);\n\nexport default {\n  v0,\n  v1,\n  polyfilled ,\n  shadowDomV0,\n  shadowDomV1\n};\n","export default function (element) {\n  var attrs = element.attributes;\n  return attrs && !!attrs['data-skate-ignore'];\n}\n","import ignored from './ignored';\n\nvar Node = window.Node;\n\nfunction walk (elem, fn) {\n  if (elem.nodeType !== Node.ELEMENT_NODE || ignored(elem)) {\n    return;\n  }\n\n  var chren = elem.childNodes;\n  var child = chren && chren[0];\n\n  fn(elem);\n  while (child) {\n    walk(child, fn);\n    child = child.nextSibling;\n  }\n}\n\nexport default function (elems, fn) {\n  if (!elems) {\n    return;\n  }\n\n  if (elems instanceof Node) {\n    elems = [elems];\n  }\n\n  for (let a = 0; a < elems.length; a++) {\n    walk(elems[a], fn);\n  }\n}\n","import elementContains from '../util/element-contains';\nimport findElementInRegistry from '../util/find-element-in-registry';\nimport support from '../native/support';\nimport walkTree from '../util/walk-tree';\n\nexport default function (...args) {\n  if (!support.polyfilled) {\n    return;\n  }\n\n  args.forEach(function (arg) {\n    const isInDom = elementContains(document, arg);\n\n    walkTree(arg, function (descendant) {\n      const component = findElementInRegistry(descendant);\n\n      if (component) {\n        if (component.prototype.createdCallback) {\n          component.prototype.createdCallback.call(descendant);\n        }\n\n        if (isInDom && component.prototype.attachedCallback) {\n          isInDom && component.prototype.attachedCallback.call(descendant);\n        }\n      }\n    });\n  });\n}\n","import assign from 'object-assign';\nimport customElements from '../native/custom-elements';\nimport init from './init';\nimport support from '../native/support';\n\nexport default function (name, props) {\n  let elem;\n  const Ctor = customElements.get(name);\n\n  if (Ctor) {\n    if (support.v1) {\n      elem = document.createElement(name, { is: Ctor.extends || null });\n    } else if (support.v0) {\n      elem = Ctor.extends ? document.createElement(Ctor.extends, name) : document.createElement(name);\n    } else {\n      if (Ctor.extends) {\n        elem = document.createElement(Ctor.extends);\n        elem.setAttribute('is', name);\n      } else {\n        elem = document.createElement(name);\n      }\n      init(elem);\n    }\n  } else {\n    elem = document.createElement(name);\n  }\n\n  return assign(elem, props);\n}\n","import utilElementContains from '../util/element-contains';\n\nconst CustomEvent = (function (CustomEvent) {\n  if (CustomEvent) {\n    try {\n      new CustomEvent();\n    } catch (e) {\n      return undefined;\n    }\n  }\n  return CustomEvent;\n}(window.CustomEvent));\n\nfunction createCustomEvent (name, opts = {}) {\n  if (CustomEvent) {\n    return new CustomEvent(name, opts);\n  }\n\n  var e = document.createEvent('CustomEvent');\n  e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n  return e;\n}\n\nfunction dispatch (elem, cEvent) {\n  if (!elem.disabled) {\n    return elem.dispatchEvent(cEvent);\n  }\n  cEvent.isPropagationStopped = true;\n}\n\nconst hasBubbleOnDetachedElements = (function () {\n  var parent = document.createElement('div');\n  var child = document.createElement('div');\n  var hasBubbleOnDetachedElements = false;\n  parent.appendChild(child);\n  parent.addEventListener('test', () => hasBubbleOnDetachedElements = true);\n  child.dispatchEvent(createCustomEvent('test', { bubbles: true }));\n  return hasBubbleOnDetachedElements;\n}());\n\nfunction createReadableStopPropagation (oldStopPropagation) {\n  return function () {\n    this.isPropagationStopped = true;\n    oldStopPropagation.call(this);\n  };\n}\n\nfunction simulateBubbling (elem, cEvent) {\n  let didPreventDefault;\n  let currentElem = elem;\n  cEvent.stopPropagation = createReadableStopPropagation(cEvent.stopPropagation);\n  Object.defineProperty(cEvent, 'target', { get: () => elem });\n  while (currentElem && !cEvent.isPropagationStopped) {\n    Object.defineProperty(cEvent, 'currentTarget', {\n      configurable: true,\n      get () { return currentElem; }\n    });\n    if (dispatch(currentElem, cEvent) === false) {\n      didPreventDefault = false;\n    }\n    currentElem = currentElem.parentNode;\n  }\n  return didPreventDefault;\n}\n\nfunction emitOne (elem, name, opts) {\n  var cEvent, shouldSimulateBubbling;\n\n  /* jshint expr: true */\n  opts.bubbles === undefined && (opts.bubbles = true);\n  opts.cancelable === undefined && (opts.cancelable = true);\n  cEvent = createCustomEvent(name, opts);\n  shouldSimulateBubbling = opts.bubbles &&\n    !hasBubbleOnDetachedElements &&\n    !utilElementContains(document, elem);\n\n  return shouldSimulateBubbling ?\n    simulateBubbling(elem, cEvent) :\n    dispatch(elem, cEvent);\n}\n\nexport default function (elem, name, opts = {}) {\n  var names = (typeof name === 'string' ? name.split(' ') : name);\n  return names.reduce(function (prev, curr) {\n    if (emitOne(elem, curr, opts) === false) {\n      prev.push(curr);\n    }\n    return prev;\n  }, []);\n}\n","export default function (element, namespace = '') {\n  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n  return namespace && (data[namespace] || (data[namespace] = {})) || data;\n}\n","import data from '../util/data';\n\nexport default function (opts) {\n  const { attached } = opts;\n  return attached ? function () {\n    const info = data(this);\n    if (info.attached) return;\n    info.attached = true;\n    info.detached = false;\n    attached(this);\n  } : undefined;\n}\n","import data from '../util/data';\nimport support from '../native/support';\n\nconst isCustomElementsV0 = support.v0;\nconst isCustomElementsV1 = support.v1;\n\nexport default function (Ctor) {\n  const { attributeChanged, observedAttributes } = Ctor;\n\n  return function (name, oldValue, newValue) {\n    const elemData = data(this);\n\n    // Chrome legacy custom elements batch attribute changes in a microtask so\n    // so we have to tell it to emulate v1 behaviour by setting a unique\n    // unique attribute.\n    if (isCustomElementsV0 && name === '____can_start_triggering_now') {\n      elemData.canStartTriggeringNow = true;\n      return;\n    }\n\n    // We prevent legacy Chrome from ever triggering a change unless it's been\n    // flagged to do so using the unique attribute or explicitly told that it\n    // can via the property data.\n    if (isCustomElementsV0 && !elemData.canStartTriggeringNow) {\n      return;\n    }\n\n    // If native support for custom elements v1 exists, then it will natively\n    // do this check before calling the attributeChangedCallback.\n    if (!isCustomElementsV1 && observedAttributes.indexOf(name) === -1) {\n      return;\n    }\n\n    const propertyName = data(this, 'attributeLinks')[name];\n\n    if (propertyName) {\n      const propData = data(this, `api/property/${propertyName}`);\n\n      // This ensures a property set doesn't cause the attribute changed\n      // handler to run again once we set this flag. This only ever has a\n      // chance to run when you set an attribute, it then sets a property and\n      // then that causes the attribute to be set again.\n      if (propData.settingAttribute) {\n        return;\n      }\n\n      // Set this here so the next set to the attribute doesn't cause this\n      // handler to run a gain.\n      propData.settingAttribute = true;\n\n      // Sync up the property.\n      if (!propData.settingProperty) {\n        const propOpts = this.constructor.properties[propertyName];\n        this[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n      }\n\n      // Allow this handler to run again.\n      propData.settingAttribute = false;\n    }\n\n    if (attributeChanged) {\n      attributeChanged(this, {\n        name: name,\n        newValue: newValue === null ? undefined : newValue,\n        oldValue: oldValue === null ? undefined : oldValue\n      });\n    }\n  };\n}\n","const elProto = window.HTMLElement.prototype;\nconst nativeMatchesSelector = (\n  elProto.matches ||\n  elProto.msMatchesSelector ||\n  elProto.webkitMatchesSelector ||\n  elProto.mozMatchesSelector ||\n  elProto.oMatchesSelector\n);\n\n// Only IE9 has this msMatchesSelector bug, but best to detect it.\nconst hasNativeMatchesSelectorDetattachedBug = !nativeMatchesSelector.call(document.createElement('div'), 'div');\n\nexport default function (element, selector) {\n  if (hasNativeMatchesSelectorDetattachedBug) {\n    const clone = element.cloneNode();\n    document.createElement('div').appendChild(clone);\n    return nativeMatchesSelector.call(clone, selector);\n  }\n  return nativeMatchesSelector.call(element, selector);\n}\n","import matches from '../util/matches-selector';\n\nfunction readonly (obj, prop, val) {\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    get () {\n      return val;\n    }\n  });\n}\n\nfunction parseEvent (e) {\n  const indexOfSpace = e.indexOf(' ');\n  const hasSpace = indexOfSpace > 0;\n  const name = hasSpace ? e.substring(0, indexOfSpace) : e;\n  const selector = hasSpace ? e.substring(indexOfSpace + 1) : '';\n  return {\n    name: name,\n    selector: selector\n  };\n}\n\nfunction makeDelegateHandler (elem, handler, parsed) {\n  return function (e) {\n    let current = e.target;\n    const selector = parsed.selector;\n    while (current && current !== elem.parentNode) {\n      if (matches(current, selector)) {\n        readonly(e, 'currentTarget', current);\n        readonly(e, 'delegateTarget', elem);\n        return handler(elem, e);\n      }\n      current = current.parentNode;\n    }\n  };\n}\n\nfunction makeNormalHandler (elem, handler) {\n  return function (e) {\n    readonly(e, 'delegateTarget', elem);\n    handler(elem, e);\n  };\n}\n\nfunction bindEvent (elem, event, handler) {\n  const parsed = parseEvent(event);\n  const { name, selector } = parsed;\n  const capture = selector && (name === 'blur' || name === 'focus');\n  handler = selector ? makeDelegateHandler(elem, handler, parsed) : makeNormalHandler(elem, handler);\n  elem.addEventListener(name, handler, capture);\n}\n\nexport default function events (opts) {\n  const events = opts.events || {};\n  return function (elem) {\n    for (let name in events) {\n      bindEvent(elem, name, events[name]);\n    }\n  };\n}\n","export default function patchAttributeMethods (elem) {\n  const { removeAttribute, setAttribute } = elem;\n\n  elem.removeAttribute = function (name) {\n    const oldValue = this.getAttribute(name);\n    removeAttribute.call(elem, name);\n    if (elem.attributeChangedCallback) {\n      elem.attributeChangedCallback(name, oldValue, null);\n    }\n  };\n\n  elem.setAttribute = function (name, newValue) {\n    const oldValue = this.getAttribute(name);\n    setAttribute.call(elem, name, newValue);\n    if (elem.attributeChangedCallback) {\n      elem.attributeChangedCallback(name, oldValue, String(newValue));\n    }\n  };\n}\n","const raf = window.requestAnimationFrame || setTimeout;\nexport default function (fn) {\n  var called = false;\n\n  return function (...args) {\n    if (!called) {\n      called = true;\n      raf(() => {\n        called = false;\n        fn.apply(this, args);\n      });\n    }\n  };\n}\n","export default function (val) {\n  return typeof val === 'undefined' || val === null;\n}","import assign from 'object-assign';\nimport data from '../util/data';\nimport debounce from '../util/debounce';\nimport emit from '../api/emit';\nimport empty from '../util/empty';\n\n// Symbol() wasn't transpiling properly.\nconst $debounce = '____debouncedRender';\n\nfunction getDefaultValue (elem, name, opts) {\n  return typeof opts.default === 'function' ? opts.default(elem, { name }) : opts.default;\n}\n\nfunction getInitialValue (elem, name, opts) {\n  return typeof opts.initial === 'function' ? opts.initial(elem, { name }) : opts.initial;\n}\n\nfunction syncAttribute (elem, propertyName, attributeName, newValue, opts) {\n  if (!attributeName) {\n    return;\n  }\n\n  const serializedValue = opts.serialize(newValue);\n\n  if (empty(serializedValue)) {\n    elem.removeAttribute(attributeName);\n  } else {\n    elem.setAttribute(attributeName, serializedValue);\n  }\n}\n\nfunction createNativePropertyDefinition (name, opts) {\n  const prop = {\n    configurable: true,\n    enumerable: true\n  };\n\n  prop.created = function (elem) {\n    const propertyData = data(elem, `api/property/${name}`);\n    const attributeName = opts.attribute;\n    let initialValue = elem[name];\n\n    // Store property to attribute link information.\n    data(elem, 'attributeLinks')[attributeName] = name;\n    data(elem, 'propertyLinks')[name] = attributeName;\n\n    // Set up initial value if it wasn't specified.\n    if (empty(initialValue)) {\n      if (attributeName && elem.hasAttribute(attributeName)) {\n        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n      } else if ('initial' in opts) {\n        initialValue = getInitialValue(elem, name, opts);\n      } else if ('default' in opts) {\n        initialValue = getDefaultValue(elem, name, opts);\n      }\n    }\n\n    // We must coerce the initial value just in case it wasn't already.\n    const internalValue = propertyData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n\n    // Since the attribute handler sets the property if the property setting\n    // didn't invoke the attribute handler, we must ensure the property\n    // setter can't be invoked by the setting of the attribute here.\n    syncAttribute(elem, name, attributeName, internalValue, opts);\n  };\n\n  prop.get = function () {\n    const propertyData = data(this, `api/property/${name}`);\n    const { internalValue } = propertyData;\n    if (typeof opts.get === 'function') {\n      return opts.get(this, { name, internalValue });\n    }\n    return internalValue;\n  };\n\n  prop.render = (function () {\n    const shouldUpdate = opts.render;\n    if (typeof shouldUpdate === 'undefined') {\n      return function (elem, data) {\n        return data.newValue !== data.oldValue;\n      };\n    }\n    if (typeof shouldUpdate === 'function') {\n      return shouldUpdate;\n    }\n    return function () {\n      return !!shouldUpdate;\n    };\n  }());\n\n  prop.set = function (newValue) {\n    const propData = data(this, `api/property/${name}`);\n\n    if (propData.settingProperty) {\n      return;\n    }\n\n    const attributeName = data(this, 'propertyLinks')[name];\n    const { oldValue } = propData;\n\n    propData.settingProperty = true;\n\n    if (empty(newValue)) {\n      newValue = getDefaultValue(this, name, opts);\n    }\n\n    if (typeof opts.coerce === 'function') {\n      newValue = opts.coerce(newValue);\n    }\n\n    const propertyHasChanged = newValue !== oldValue;\n    if (propertyHasChanged && opts.event) {\n      const cancelledEvents = emit(this, String(opts.event), {\n        bubbles: false,\n        cancelable: true,\n        detail: { name, oldValue, newValue }\n      });\n\n      if (cancelledEvents.length > 0) {\n        propData.settingProperty = false;\n        return;\n      }\n    }\n\n    propData.internalValue = newValue;\n    syncAttribute(this, name, attributeName, newValue, opts);\n\n    const changeData = { name, newValue, oldValue };\n\n    if (typeof opts.set === 'function') {\n      opts.set(this, changeData);\n    }\n\n    // Re-render on property updates if the should-update check passes.\n    if (prop.render(this, changeData)) {\n      const deb = this[$debounce] || (this[$debounce] = debounce(this.constructor.render));\n      deb(this);\n    }\n\n    propData.settingProperty = false;\n    propData.oldValue = newValue;\n  };\n\n  return prop;\n}\n\nexport default function (opts) {\n  opts = opts || {};\n\n  if (typeof opts === 'function') {\n    opts = { coerce: opts };\n  }\n\n  return function (name) {\n    return createNativePropertyDefinition(name, assign({\n      deserialize: value => value,\n      serialize: value => value\n    }, opts));\n  };\n}\n","export default function (proto) {\n  var chains = [];\n  while (proto) {\n    chains.push(proto);\n    proto = Object.getPrototypeOf(proto);\n  }\n  chains.reverse();\n  return chains;\n}\n","export default function (obj, props) {\n  Object.keys(props).forEach(function (name) {\n    const prop = props[name];\n    const descriptor = Object.getOwnPropertyDescriptor(obj, name);\n    const isDinosaurBrowser = name !== 'arguments' && name !== 'caller' && 'value' in prop;\n    const isConfigurable = !descriptor || descriptor.configurable;\n    const isWritable = !descriptor || descriptor.writable;\n\n    if (isConfigurable) {\n      Object.defineProperty(obj, name, prop);\n    } else if (isDinosaurBrowser && isWritable) {\n      obj[name] = prop.value;\n    }\n  });\n}\n","export default function (obj) {\n  return Object.getOwnPropertyNames(obj).reduce(function (prev, curr) {\n    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n    return prev;\n  }, {});\n}","import protos from '../util/protos';\nimport utilDefineProperties from '../util/define-properties';\nimport utilGetOwnPropertyDescriptors from '../util/get-own-property-descriptors';\n\nexport default function prototype (opts) {\n  const prototypes = protos(opts.prototype);\n  return function (elem) {\n    prototypes.forEach(function (proto) {\n      if (!proto.isPrototypeOf(elem)) {\n        utilDefineProperties(elem, utilGetOwnPropertyDescriptors(proto));\n      }\n    });\n  };\n}\n","import data from '../util/data';\nimport eventsApplier from './events';\nimport patchAttributeMethods from './patch-attribute-methods';\nimport propertiesInit from './properties-init';\nimport prototypeApplier from './prototype';\nimport support from '../native/support';\n\nconst isPolyfilled = support.polyfilled;\nconst isCustomElementsV0 = support.v0;\nconst isCustomElementsV1 = support.v1;\n\nfunction ensurePropertyFunctions (opts) {\n  let properties = opts.properties;\n  let names = Object.keys(properties || {});\n  return names.reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = opts.properties[descriptorName];\n    if (typeof descriptors[descriptorName] !== 'function') {\n      descriptors[descriptorName] = propertiesInit(descriptors[descriptorName]);\n    }\n    return descriptors;\n  }, {});\n}\n\nfunction ensurePropertyDefinitions (elem, propertyFunctions) {\n  return Object.keys(propertyFunctions || {}).reduce(function (descriptors, descriptorName) {\n    descriptors[descriptorName] = propertyFunctions[descriptorName](descriptorName);\n    return descriptors;\n  }, {});\n}\n\nfunction callAttributeChangedForEachAttribute (elem, observedAttributes) {\n  observedAttributes.forEach(function (name) {\n    const attr = elem.attributes[name];\n\n    // We don't call it for the defined attribute because that will have\n    // already called the handler via setAttribute().\n    if (attr) {\n      elem.attributeChangedCallback(name, null, attr.value);\n    }\n  });\n}\n\nfunction initialiseProperties (elem, propertyDefinitions) {\n  Object.keys(propertyDefinitions).forEach(function (name) {\n    const prop = propertyDefinitions[name];\n    prop.created(elem);\n\n    // https://bugs.webkit.org/show_bug.cgi?id=49739\n    //\n    // When Webkit fixes that bug so that native property accessors can be\n    // retrieved, we can move defining the property to the prototype and away\n    // from having to do if for every instance as all other browsers support\n    // this.\n    Object.defineProperty(elem, name, prop);\n  });\n}\n\nexport default function (opts) {\n  const {\n    created,\n    definedAttribute,\n    events,\n    observedAttributes,\n    properties,\n    prototype,\n    ready,\n    render,\n    renderedAttribute\n  } = opts;\n  const applyEvents = eventsApplier(opts);\n  const applyPrototype = prototypeApplier(opts);\n  const propertyFunctions = ensurePropertyFunctions(opts);\n\n  // Performance critical code!\n  return function () {\n    const elemData = data(this);\n    const propertyDefinitions = properties ? ensurePropertyDefinitions(this, propertyFunctions) : null;\n    const readyCallbacks = elemData.readyCallbacks;\n\n    if (elemData.created) {\n      return;\n    }\n\n    elemData.created = true;\n\n    if (isPolyfilled && prototype) {\n      applyPrototype(this);\n    }\n\n    // Sets up properties, but does not invoke anything.\n    if (propertyDefinitions) {\n      initialiseProperties(this, propertyDefinitions);\n    }\n\n    if (events) {\n      applyEvents(this);\n    }\n\n    if (created) {\n      created(this);\n    }\n\n    if (render && !this.hasAttribute(renderedAttribute)) {\n      render(this);\n    }\n\n    if (ready) {\n      ready(this);\n    }\n\n    // Defined attribute is last before notifying listeners.\n    if (!this.hasAttribute(definedAttribute)) {\n      this.setAttribute(definedAttribute, '');\n    }\n\n    // We trigger ready after we add the defined attribute.\n    if (readyCallbacks) {\n      readyCallbacks.forEach(cb => cb());\n      elemData.readyCallbacks = null;\n    }\n\n    // In the early versions of the spec (\"v0\", only implemented by Blink) all\n    // calls to setAttribute() would queue a task to execute the attributeChangedCallback.\n    // However, no attributes that exist when the element is upgraded would queue\n    // a task.\n    //\n    // In Custom Elements v1, nothing is queued until after the constructor\n    // (createdCallback in v0) is invoked. After it is invoked, the\n    // attributeChangedCallback() is executed for all existing attributes. All\n    // subsequent calls behave as normal.\n    //\n    // Any attribute change before this point is a no-op. Anything after works\n    // as normal.\n    if (isCustomElementsV0) {\n      this.setAttribute('____can_start_triggering_now', '');\n      this.removeAttribute('____can_start_triggering_now');\n    }\n\n    // Make attribute sets synchronous for polyfill-land.\n    if (isPolyfilled) {\n      patchAttributeMethods(this);\n    }\n\n    // Emulate v1 attribute initialisation behaviour.\n    if (!isCustomElementsV1) {\n      // We force this flag to be true so that attributeChanged() actually gets\n      // called in Chrome v0.\n      elemData.canStartTriggeringNow = true;\n\n      // Force the change.\n      callAttributeChangedForEachAttribute(this, observedAttributes);\n\n      // Now we turn it off so that Chrome v0 doesn't trigger attributeChanged()\n      // until *after* it receives the set for \"____can_start_triggering_now\".\n      elemData.canStartTriggeringNow = false;\n    }\n  };\n}\n","export default function (str) {\n  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n    var dash = !one || idx % 2 === 0 ? '' : '-';\n    return `${one}${dash}${two.toLowerCase()}`;\n  });\n}\n","export default {\n  applyProp: {}\n};\n","const nope = null;\n\nexport default {\n  attached: nope,\n  attribute: nope,\n  created: nope,\n  definedAttribute: 'defined',\n  render: nope,\n  detached: nope,\n  events: nope,\n  extends: nope,\n  properties: nope,\n  prototype: {},\n  ready: nope,\n  renderedAttribute: 'rendered'\n};\n","import data from '../util/data';\n\nexport default function (opts) {\n  const { detached } = opts;\n  return detached ? function () {\n    const info = data(this);\n    if (info.detached) return;\n    info.detached = true;\n    info.attached = false;\n    detached(this);\n  } : undefined;\n}\n","const isIeUntil10 = /MSIE/.test(navigator.userAgent);\nconst isIe11 = /Trident/.test(navigator.userAgent);\nconst isIe = isIeUntil10 || isIe11;\nconst elementPrototype = window.HTMLElement.prototype;\n\n// ! This walkTree method differs from the implementation in ../../utils/walk-tree\n// It invokes the callback only for the children, not the passed node and the second parameter to the callback is the parent node\nfunction walkTree (node, cb) {\n  const childNodes = node.childNodes;\n\n  if (!childNodes) {\n    return;\n  }\n\n  const childNodesLen = childNodes.length;\n\n  for (let a = 0; a < childNodesLen; a++) {\n    const childNode = childNodes[a];\n    cb(childNode, node);\n    walkTree(childNode, cb);\n  }\n}\n\nfunction fixInnerHTML() {\n  const originalInnerHTML = Object.getOwnPropertyDescriptor(elementPrototype, 'innerHTML');\n\n  var get = function () {\n    return originalInnerHTML.get.call(this);\n  };\n  get._hasBeenEnhanced =  true;\n\n  // This redefines the innerHTML property so that we can ensure that events\n  // are properly triggered.\n  Object.defineProperty(elementPrototype, 'innerHTML', {\n    get: get,\n    set: function (html) {\n      walkTree(this, function (node, parentNode) {\n        let mutationEvent = document.createEvent('MutationEvent');\n        mutationEvent.initMutationEvent('DOMNodeRemoved', true, false, parentNode, null, null, null, null);\n        node.dispatchEvent(mutationEvent);\n      });\n      originalInnerHTML.set.call(this, html);\n    }\n  });\n}\n\nif (isIe) {\n  // IE 9-11\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(elementPrototype, 'innerHTML');\n  const hasBeenEnhanced = !!propertyDescriptor && propertyDescriptor.get._hasBeenEnhanced;\n\n  if (!hasBeenEnhanced) {\n    if (isIe11) {\n      // IE11's native MutationObserver needs some help as well :()\n      window.MutationObserver = window.JsMutationObserver || window.MutationObserver;\n    }\n\n    fixInnerHTML();\n  }\n}\n","import ignored from './ignored';\n\nconst { Element } = window;\n\nexport default function (element) {\n  let parent = element;\n  while (parent instanceof Element) {\n    if (ignored(parent)) {\n      return parent;\n    }\n    parent = parent.parentNode;\n  }\n}\n","import '../fix/ie/innerhtml';\nimport findElementInRegistry from '../util/find-element-in-registry';\nimport getClosestIgnoredElement from '../util/get-closest-ignored-element';\nimport walkTree from '../util/walk-tree';\n\nfunction triggerAddedNodes (addedNodes) {\n  walkTree(addedNodes, function (element) {\n    const component = findElementInRegistry(element);\n\n    if (component) {\n      if (component.prototype.createdCallback) {\n        component.prototype.createdCallback.call(element);\n      }\n\n      if (component.prototype.attachedCallback) {\n        component.prototype.attachedCallback.call(element);\n      }\n    }\n  });\n}\n\nfunction triggerRemovedNodes (removedNodes) {\n  walkTree(removedNodes, function (element) {\n    const component = findElementInRegistry(element);\n\n    if (component && component.prototype.detachedCallback) {\n      component.prototype.detachedCallback.call(element);\n    }\n  });\n}\n\nfunction documentObserverHandler (mutations) {\n  const mutationsLength = mutations.length;\n  for (let a = 0; a < mutationsLength; a++) {\n    const addedNodes = mutations[a].addedNodes;\n    const removedNodes = mutations[a].removedNodes;\n\n    // Since siblings are batched together, we check the first node's parent\n    // node to see if it is ignored. If it is then we don't process any added\n    // nodes. This prevents having to check every node.\n    if (addedNodes && addedNodes.length && !getClosestIgnoredElement(addedNodes[0].parentNode)) {\n      triggerAddedNodes(addedNodes);\n    }\n\n    // We can't check batched nodes here because they won't have a parent node.\n    if (removedNodes && removedNodes.length) {\n      triggerRemovedNodes(removedNodes);\n    }\n  }\n}\n\nfunction createMutationObserver () {\n  const { MutationObserver } = window;\n  if (!MutationObserver) {\n    throw new Error('Mutation Observers are not supported by this browser. Skate requires them in order to polyfill the behaviour of Custom Elements. If you want to support this browser you should include a Mutation Observer polyfill before Skate.');\n  }\n  return new MutationObserver(documentObserverHandler);\n}\n\nfunction createDocumentObserver () {\n  const observer = createMutationObserver();\n  observer.observe(document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nexport default {\n  observer: undefined,\n  register: function () {\n    if (!this.observer) {\n      this.observer = createDocumentObserver();\n    }\n    return this;\n  },\n  unregister: function () {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n    return this;\n  }\n};\n","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nvar inAttributes = false;\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nvar inSkip = false;\n\n/**\n * Makes sure that there is a current patch context.\n * @param {*} context\n */\nvar assertInPatch = function (context) {\n  if (!context) {\n    throw new Error('Cannot call currentElement() unless in patch');\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nvar assertNoUnclosedTags = function (openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  var currentElement = openElement;\n  var openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n};\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nvar assertNotInAttributes = function (functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() may not be called between ' + 'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nvar assertNotInSkip = function (functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');\n  }\n};\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nvar assertInAttributes = function (functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() must be called after ' + 'elementOpenStart().');\n  }\n};\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nvar assertVirtualAttributesClosed = function () {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');\n  }\n};\n\n/**\n  * Makes sure that placeholders have a key specified. Otherwise, conditional\n  * placeholders and conditional elements next to placeholders will cause\n  * placeholder elements to be re-used as non-placeholders and vice versa.\n  * @param {string} key\n  */\nvar assertPlaceholderKeySpecified = function (key) {\n  if (!key) {\n    throw new Error('Placeholder elements must have a key specified.');\n  }\n};\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nvar assertCloseMatchesOpenTag = function (nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close ' + tag + ' but ' + nodeName + ' was open.');\n  }\n};\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nvar assertNoChildrenDeclaredYet = function (functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');\n  }\n};\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInAttributes = function (value) {\n  var previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nvar setInSkip = function (value) {\n  var previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nexports.notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = exports.notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = exports.notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    exports.notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    exports.notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nexports.applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nexports.applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    exports.applyProp(el, name, value);\n  } else {\n    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nexports.attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nexports.attributes[exports.symbols.default] = applyAttributeTyped;\n\nexports.attributes[exports.symbols.placeholder] = function () {};\n\nexports.attributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode;\n\n/** @type {?Node} */\nvar currentParent;\n\n/** @type {?Node} */\nvar previousNode;\n\n/** @type {?Element|?DocumentFragment} */\nvar root;\n\n/** @type {?Document} */\nvar doc;\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nexports.patch = function (node, fn, data) {\n  var prevContext = context;\n  var prevRoot = root;\n  var prevDoc = doc;\n  var prevCurrentNode = currentNode;\n  var prevCurrentParent = currentParent;\n  var prevPreviousNode = previousNode;\n  var previousInAttributes = false;\n  var previousInSkip = false;\n\n  context = new Context();\n  root = node;\n  doc = node.ownerDocument;\n  currentNode = node;\n  currentParent = null;\n  previousNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    previousInAttributes = setInAttributes(false);\n    previousInSkip = setInSkip(false);\n  }\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertVirtualAttributesClosed();\n    assertNoUnclosedTags(previousNode, node);\n    setInAttributes(previousInAttributes);\n    setInSkip(previousInSkip);\n  }\n\n  context.notifyChanges();\n\n  context = prevContext;\n  root = prevRoot;\n  doc = prevDoc;\n  currentNode = prevCurrentNode;\n  currentParent = prevCurrentParent;\n  previousNode = prevPreviousNode;\n};\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && process.env.NODE_ENV !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key;\n\n  if (child === previousNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[exports.symbols.placeholder] && node !== root) {\n    return;\n  }\n\n  while (child !== previousNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = currentNode.firstChild;\n  previousNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  previousNode = currentNode;\n  currentNode = currentNode.nextSibling;\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  previousNode = currentParent;\n  currentNode = currentParent.nextSibling;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar _elementOpen = function (tag, key, statics) {\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar _elementClose = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return (/** @type {!Element} */previousNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar _text = function () {\n  alignWithDOM('#text', null, null);\n  nextNode();\n  return (/** @type {!Text} */previousNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nexports.currentElement = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch(context);\n    assertNotInAttributes('currentElement');\n  }\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nexports.skip = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', previousNode);\n    setInSkip(true);\n  }\n  previousNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpen = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  var node = _elementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nexports.elementOpenStart = function (tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nexports.attr = function (name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpenEnd = function () {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  var node = exports.elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nexports.elementClose = function (tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  var node = _elementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementVoid = function (tag, key, statics, var_args) {\n  var node = exports.elementOpen.apply(null, arguments);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementPlaceholder = function (tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  exports.elementOpen.apply(null, arguments);\n  exports.skip();\n  return exports.elementClose.apply(null, arguments);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nexports.text = function (value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  var node = _text();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n//# sourceMappingURL=incremental-dom-cjs.js.map","import * as IncrementalDOM from 'incremental-dom';\nimport internalData from '../data';\nimport support from '../native/support';\n\n// Could import these, but we have to import all of IncrementalDOM anyways so\n// that we can export our configured IncrementalDOM.\nconst {\n  applyProp,\n  attr,\n  attributes,\n  elementClose,\n  elementOpen,\n  elementOpenEnd,\n  elementOpenStart,\n  skip,\n  symbols,\n  text\n} = IncrementalDOM;\n\n// Specify an environment for iDOM in case we haven't yet.\nif (typeof process === 'undefined') {\n  /* eslint no-undef: 0 */\n  process = { env: { NODE_ENV: 'production' } };\n}\n\nconst applyDefault = attributes[symbols.default];\nconst factories = {};\n\n// Attributes that are not handled by Incremental DOM.\nattributes.key = attributes.skip = attributes.statics = function () {};\n\n// Attributes that *must* be set via a property on all elements.\nattributes.checked = attributes.className = attributes.disabled = attributes.value = applyProp;\n\n// Default attribute applicator.\nattributes[symbols.default] = function (elem, name, value) {\n  // Boolean false values should not set attributes at all.\n  if (value === false) {\n    return;\n  }\n\n  // Work with properties defined on the prototype chain. This includes event\n  // handlers that can be bound via properties.\n  if (name in elem) {\n    return applyProp(elem, name, value);\n  }\n\n  // Handle custom events.\n  if (name.indexOf('on') === 0) {\n    return applyEvent(elem, name.substring(2), name, value);\n  }\n\n  // Custom element properties should be set as properties.\n  const dataName = elem.tagName + '.' + name;\n  if (internalData.applyProp[dataName]) {\n    return applyProp(elem, name, value);\n  }\n\n  // Fallback to default IncrementalDOM behaviour.\n  applyDefault(elem, name, value);\n};\n\n// Adds or removes an event listener for an element.\nfunction applyEvent (elem, ename, name, value) {\n  let events = elem.__events;\n\n  if (!events) {\n    events = elem.__events = {};\n  }\n\n  const eFunc = events[ename];\n\n  // Remove old listener so they don't double up.\n  if (eFunc) {\n    elem.removeEventListener(ename, eFunc);\n  }\n\n  // Bind new listener.\n  if (value) {\n    elem.addEventListener(ename, events[ename] = function (e) {\n      if (this === e.target) {\n        value.call(this, e);\n      }\n    });\n  }\n}\n\n// Creates a factory and returns it.\nfunction bind (tname) {\n  if (typeof tname === 'function') {\n    tname = tname.id || tname.name;\n  }\n\n  return factories[tname] = function (attrs, chren) {\n    if (attrs && typeof attrs === 'object') {\n      elementOpenStart(tname, attrs.key, attrs.statics);\n      for (let a in attrs) {\n        attr(a, attrs[a]);\n      }\n      elementOpenEnd();\n    } else {\n      elementOpen(tname);\n      chren = attrs;\n      attrs = {};\n    }\n\n    if (attrs.skip) {\n      skip();\n    } else {\n      const chrenType = typeof chren;\n      if (chrenType === 'function') {\n        chren();\n      } else if (chrenType === 'string' || chrenType === 'number') {\n        text(chren);\n      }\n    }\n\n    return elementClose(tname);\n  };\n}\n\n// The default function requries a tag name.\nexport default function create (tname, attrs, chren) {\n  // Abstract Shadow DOM V0 <content> behind Shadow DOM V1 <slot>.\n  if (tname === 'slot') {\n    if (support.shadowDomV0) {\n      if (attrs && attrs.slot) {\n        attrs.select = `[slot=\"${attrs.slot}\"]`;\n        delete attrs.slot;\n      }\n      tname = 'content';\n    }\n  }\n  return (factories[tname] || bind(tname))(attrs, chren);\n}\n\n// Export the Incremental DOM text() function directly as we don't need to do\n// any special processing for it.\nexport { text };\n\n// We export IncrementalDOM in its entirety because we want the user to be able\n// to user our configured version while still being able to use various other\n// templating languages and techniques that compile down to it.\nexport { IncrementalDOM };\n\n// Create factories for all HTML elements except for ones that match keywords\n// such as \"var\".\nexport const a = bind('a');\nexport const abbr = bind('abbr');\nexport const address = bind('address');\nexport const area = bind('area');\nexport const article = bind('article');\nexport const aside = bind('aside');\nexport const audio = bind('audio');\nexport const b = bind('b');\nexport const base = bind('base');\nexport const bdi = bind('bdi');\nexport const bdo = bind('bdo');\nexport const bgsound = bind('bgsound');\nexport const blockquote = bind('blockquote');\nexport const body = bind('body');\nexport const br = bind('br');\nexport const button = bind('button');\nexport const canvas = bind('canvas');\nexport const caption = bind('caption');\nexport const cite = bind('cite');\nexport const code = bind('code');\nexport const col = bind('col');\nexport const colgroup = bind('colgroup');\nexport const command = bind('command');\nexport const content = bind('content');\nexport const data = bind('data');\nexport const datalist = bind('datalist');\nexport const dd = bind('dd');\nexport const del = bind('del');\nexport const details = bind('details');\nexport const dfn = bind('dfn');\nexport const dialog = bind('dialog');\nexport const div = bind('div');\nexport const dl = bind('dl');\nexport const dt = bind('dt');\nexport const element = bind('element');\nexport const em = bind('em');\nexport const embed = bind('embed');\nexport const fieldset = bind('fieldset');\nexport const figcaption = bind('figcaption');\nexport const figure = bind('figure');\nexport const font = bind('font');\nexport const footer = bind('footer');\nexport const form = bind('form');\nexport const h1 = bind('h1');\nexport const h2 = bind('h2');\nexport const h3 = bind('h3');\nexport const h4 = bind('h4');\nexport const h5 = bind('h5');\nexport const h6 = bind('h6');\nexport const head = bind('head');\nexport const header = bind('header');\nexport const hgroup = bind('hgroup');\nexport const hr = bind('hr');\nexport const html = bind('html');\nexport const i = bind('i');\nexport const iframe = bind('iframe');\nexport const image = bind('image');\nexport const img = bind('img');\nexport const input = bind('input');\nexport const ins = bind('ins');\nexport const kbd = bind('kbd');\nexport const keygen = bind('keygen');\nexport const label = bind('label');\nexport const legend = bind('legend');\nexport const li = bind('li');\nexport const link = bind('link');\nexport const main = bind('main');\nexport const map = bind('map');\nexport const mark = bind('mark');\nexport const marquee = bind('marquee');\nexport const menu = bind('menu');\nexport const menuitem = bind('menuitem');\nexport const meta = bind('meta');\nexport const meter = bind('meter');\nexport const multicol = bind('multicol');\nexport const nav = bind('nav');\nexport const nobr = bind('nobr');\nexport const noembed = bind('noembed');\nexport const noframes = bind('noframes');\nexport const noscript = bind('noscript');\nexport const object = bind('object');\nexport const ol = bind('ol');\nexport const optgroup = bind('optgroup');\nexport const option = bind('option');\nexport const output = bind('output');\nexport const p = bind('p');\nexport const param = bind('param');\nexport const picture = bind('picture');\nexport const pre = bind('pre');\nexport const progress = bind('progress');\nexport const q = bind('q');\nexport const rp = bind('rp');\nexport const rt = bind('rt');\nexport const rtc = bind('rtc');\nexport const ruby = bind('ruby');\nexport const s = bind('s');\nexport const samp = bind('samp');\nexport const script = bind('script');\nexport const section = bind('section');\nexport const select = bind('select');\nexport const shadow = bind('shadow');\nexport const slot = bind('slot');\nexport const small = bind('small');\nexport const source = bind('source');\nexport const span = bind('span');\nexport const strong = bind('strong');\nexport const style = bind('style');\nexport const sub = bind('sub');\nexport const summary = bind('summary');\nexport const sup = bind('sup');\nexport const table = bind('table');\nexport const tbody = bind('tbody');\nexport const td = bind('td');\nexport const template = bind('template');\nexport const textarea = bind('textarea');\nexport const tfoot = bind('tfoot');\nexport const th = bind('th');\nexport const thead = bind('thead');\nexport const time = bind('time');\nexport const title = bind('title');\nexport const tr = bind('tr');\nexport const track = bind('track');\nexport const u = bind('u');\nexport const ul = bind('ul');\nexport const video = bind('video');\nexport const wbr = bind('wbr');\n","import { IncrementalDOM } from '../api/vdom';\n\nconst { patch } = IncrementalDOM;\nconst symbolShadowRoot = '____shadow_root';\n\nexport default function (opts) {\n  const internalRenderer = opts.render;\n  return function (elem) {\n    if (!internalRenderer) {\n      return;\n    }\n\n    let shadowRoot;\n\n    if (!elem[symbolShadowRoot]) {\n      if (elem.attachShadow) {\n        shadowRoot = elem.attachShadow({ mode: 'open' });\n      } else {\n        shadowRoot = elem.createShadowRoot();\n      }\n      elem[symbolShadowRoot] = shadowRoot;\n    }\n\n    patch(elem[symbolShadowRoot], internalRenderer, elem);\n  };\n}\n","import getOwnPropertyDescriptors from './get-own-property-descriptors';\nimport protos from './protos';\n\nexport default function (obj) {\n  return protos(obj).reduce(function (result, proto) {\n    const descriptors = getOwnPropertyDescriptors(proto);\n    Object.getOwnPropertyNames(descriptors).reduce(function (result, name) {\n      result[name] = descriptors[name];\n      return result;\n    }, result);\n    return result;\n  }, {});\n}\n","import assign from 'object-assign';\nimport attached from '../lifecycle/attached';\nimport attribute from '../lifecycle/attribute-changed';\nimport create from './create';\nimport created from '../lifecycle/created';\nimport customElements from '../native/custom-elements';\nimport dashCase from '../util/dash-case';\nimport data from '../data';\nimport defaults from '../defaults';\nimport detached from '../lifecycle/detached';\nimport documentObserver from '../native/document-observer';\nimport render from '../lifecycle/render';\nimport support from '../native/support';\nimport utilGetAllPropertyDescriptors from '../util/get-all-property-descriptors';\nimport utilGetOwnPropertyDescriptors from '../util/get-own-property-descriptors';\nimport utilDebounce from '../util/debounce';\nimport utilDefineProperties from '../util/define-properties';\nimport utilWalkTree from '../util/walk-tree';\n\nconst HTMLElement = window.HTMLElement;\n\n// A function that initialises the document once in a given event loop.\nconst initDocument = utilDebounce(function () {\n  utilWalkTree(document.documentElement.childNodes, function (element) {\n    const component = customElements.get(element.tagName.toLowerCase());\n\n    if (component) {\n      if (component.prototype.createdCallback) {\n        component.prototype.createdCallback.call(element);\n      }\n\n      if (component.prototype.attachedCallback) {\n        component.prototype.attachedCallback.call(element);\n      }\n    }\n  });\n});\n\n// Creates a configurable, non-writable, non-enumerable property.\nfunction fixedProp (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: false,\n    value,\n    writable: false\n  });\n}\n\n// Makes a function / constructor that can be called as either.\nfunction createConstructor (name, opts) {\n  const func = create.bind(null, name);\n\n  // Assigning defaults gives a predictable definition and prevents us from\n  // having to do defaults checks everywhere.\n  assign(func, defaults);\n\n  // Inherit all options. This takes into account object literals as well as\n  // ES2015 classes that may have inherited static props which would not be\n  // considered \"own\".\n  utilDefineProperties(func, utilGetAllPropertyDescriptors(opts));\n\n  return func;\n}\n\nfunction addConstructorInformation (name, Ctor) {\n  fixedProp(Ctor.prototype, 'constructor', Ctor);\n  fixedProp(Ctor, 'id', name);\n\n  // In native, the function name is the same as the custom element name, but\n  // WebKit prevents this from being defined. We do this where possible and\n  // still define `id` for cross-browser compatibility.\n  const nameProp = Object.getOwnPropertyDescriptor(Ctor, 'name');\n  if (nameProp && nameProp.configurable) {\n    fixedProp(Ctor, 'name', name);\n  }\n}\n\n// When passing props, Incremental DOM defaults to setting an attribute. When\n// you pass around data to components it's better to use properties because you\n// can pass things other than strings. This tells incremental DOM to use props\n// for all defined properties on components.\nfunction ensureIncrementalDomKnowsToSetPropsForLinkedAttrs (name, opts) {\n  Object.keys(opts).forEach(function (optKey) {\n    const propKey = name + '.' + optKey;\n    data.applyProp[propKey] = true;\n  });\n}\n\n// Ensures linked properties that have linked attributes are pre-formatted to\n// the attribute name in which they are linked.\nfunction ensureLinkedAttributesAreFormatted (opts) {\n  const { observedAttributes, properties } = opts;\n\n  if (!properties) {\n    return;\n  }\n\n  Object.keys(properties).forEach(function (name) {\n    const prop = properties[name];\n    const attr = prop.attribute;\n    if (attr) {\n      // Ensure the property is updated.\n      const linkedAttr = prop.attribute = attr === true ? dashCase(name) : attr;\n\n      // Automatically observe the attribute since they're linked from the\n      // attributeChangedCallback.\n      if (observedAttributes.indexOf(linkedAttr) === -1) {\n        observedAttributes.push(linkedAttr);\n      }\n    }\n  });\n}\n\n// The main skate() function.\nexport default function (name, opts) {\n  // Ensure the observed attributes are initialised.\n  opts.observedAttributes = opts.observedAttributes || [];\n\n  // Ensure the render function render's using Incremental DOM.\n  opts.render = render(opts);\n\n  const Ctor = createConstructor(name, opts);\n  addConstructorInformation(name, Ctor);\n  ensureIncrementalDomKnowsToSetPropsForLinkedAttrs(name, Ctor);\n  ensureLinkedAttributesAreFormatted(Ctor);\n\n  // If the options don't inherit a native element prototype, we ensure it does\n  // because native requires you explicitly do this. Here we solve the common\n  // use case by defaulting to HTMLElement.prototype.\n  if (!HTMLElement.prototype.isPrototypeOf(Ctor.prototype) && !SVGElement.prototype.isPrototypeOf(Ctor.prototype)) {\n    const proto = (Ctor.extends ? document.createElement(Ctor.extends).constructor : HTMLElement).prototype;\n    Ctor.prototype = Object.create(proto, utilGetOwnPropertyDescriptors(Ctor.prototype));\n  }\n\n  // We assign native callbacks to handle the callbacks specified in the\n  // Skate definition. This allows us to abstract away any changes that may\n  // occur in the spec.\n  assign(Ctor.prototype, {\n    createdCallback: created(Ctor),\n    attachedCallback: attached(Ctor),\n    detachedCallback: detached(Ctor),\n    attributeChangedCallback: attribute(Ctor)\n  });\n\n  // In polyfill land we must emulate what the browser would normally do in\n  // native.\n  if (support.polyfilled) {\n    initDocument();\n    documentObserver.register();\n  }\n\n  customElements.define(name, Ctor);\n  return customElements.get(name);\n}\n","import skate from './skate';\n\nexport default function (opts) {\n  return function (name) {\n    return skate(name, opts);\n  };\n}\n","import init from './init';\n\nconst { Node, NodeList } = window;\nconst slice = Array.prototype.slice;\nconst specialMap = {\n  caption: 'table',\n  dd: 'dl',\n  dt: 'dl',\n  li: 'ul',\n  tbody: 'table',\n  td: 'tr',\n  thead: 'table',\n  tr: 'tbody'\n};\n\nfunction resolveParent (tag, html) {\n  const container = document.createElement('div');\n  let levels = 0;\n  let parentTag = specialMap[tag];\n\n  while (parentTag) {\n    html = `<${parentTag}>${html}</${parentTag}>`;\n    ++levels;\n    parentTag = specialMap[parentTag];\n  }\n\n  container.innerHTML = html;\n\n  let parent = container;\n  for (let a = 0; a < levels; a++) {\n    parent = parent.firstElementChild;\n  }\n  return parent;\n}\n\nfunction resolveTag (html) {\n  const tag = html.match(/^<([^\\s>]+)/);\n  return tag && tag[1];\n}\n\nfunction resolveHtml (html) {\n  return resolveParent(resolveTag(html), html);\n}\n\nexport default function fragment (...args) {\n  return args.reduce(function (frag, node) {\n    if (typeof node === 'string') {\n      node = fragment.apply(null, slice.call(resolveHtml(node).childNodes));\n    } else if (node instanceof NodeList || Array.isArray(node)) {\n      node = fragment.apply(null, slice.call(node));\n    } else if (node instanceof Node) {\n      init(node);\n    }\n\n    if (node) {\n      frag.appendChild(node);\n    }\n\n    return frag;\n  }, document.createDocumentFragment());\n}\n","import assign from 'object-assign';\n\nfunction get (elem) {\n  const props = elem.constructor.properties;\n  const state = {};\n  for (let key in props) {\n    const val = elem[key];\n    if (typeof val !== 'undefined') {\n      state[key] = val;\n    }\n  }\n  return state;\n}\n\nfunction set (elem, newState) {\n  assign(elem, newState);\n  elem.constructor.render(elem);\n}\n\nexport default function (elem, newState) {\n  return typeof newState === 'undefined' ? get(elem) : set(elem, newState);\n}\n","import state from './state';\n\nfunction getValue (elem) {\n  const type = elem.type;\n  if (type === 'checkbox' || type === 'radio') {\n    return elem.checked ? elem.value || true : false;\n  }\n  return elem.value;\n}\n\nexport default function (elem, target) {\n  return function (e) {\n    const value = getValue(e.target);\n    const localTarget = target || e.target.name || 'value';\n\n    if (localTarget.indexOf('.') > -1) {\n      const parts = localTarget.split('.');\n      const firstPart = parts[0];\n      const propName = parts.pop();\n      const obj = parts.reduce(function (prev, curr) {\n        return prev && prev[curr];\n      }, elem);\n\n      obj[propName || e.target.name] = value;\n      state(elem, {\n        [firstPart]: elem[firstPart]\n      });\n    } else {\n      state(elem, {\n        [localTarget]: value\n      });\n    }\n  };\n}\n","export default {\n  coerce: val => Array.isArray(val) ? val : [val],\n  default: () => [],\n  deserialize: JSON.parse,\n  serialize: JSON.stringify\n};\n","export default {\n  coerce: value => !!value,\n  default: false,\n  deserialize: value => !(value === null),\n  serialize: value => value ? '' : undefined\n};\n","import empty from '../../util/empty';\n\nconst alwaysUndefinedIfEmpty = val => empty(val) ? undefined : Number(val);\n\nexport default {\n  coerce: alwaysUndefinedIfEmpty,\n  deserialize: alwaysUndefinedIfEmpty,\n  serialize: alwaysUndefinedIfEmpty\n};\n","import empty from '../../util/empty';\n\nconst alwaysUndefinedIfEmpty = val => empty(val) ? undefined : String(val);\n\nexport default {\n  coerce: alwaysUndefinedIfEmpty,\n  deserialize: alwaysUndefinedIfEmpty,\n  serialize: alwaysUndefinedIfEmpty\n};\n","import assign from 'object-assign';\nimport propArray from './array';\nimport propBoolean from './boolean';\nimport propNumber from './number';\nimport propString from './string';\n\nexport default function prop (def) {\n  return function (...args) {\n    args.unshift({}, def);\n    return assign.apply(null, args);\n  };\n}\n\nexport const array = prop(propArray);\nexport const boolean = prop(propBoolean);\nexport const number = prop(propNumber);\nexport const string = prop(propString);\n","import data from '../util/data';\nimport findElementInRegistry from '../util/find-element-in-registry';\n\nfunction ready (element) {\n  const component = findElementInRegistry(element);\n  return component && data(element).created;\n}\n\nexport default function (elements, callback) {\n  const collection = elements.length === undefined ? [elements] : elements;\n  const collectionLength = collection.length;\n  let readyCount = 0;\n\n  function callbackIfReady () {\n    ++readyCount;\n    if (readyCount === collectionLength) {\n      callback(elements);\n    }\n  }\n\n  for (let a = 0; a < collectionLength; a++) {\n    const elem = collection[a];\n\n    if (ready(elem)) {\n      callbackIfReady();\n    } else {\n      const info = data(elem);\n      if (info.readyCallbacks) {\n        info.readyCallbacks.push(callbackIfReady);\n      } else {\n        info.readyCallbacks = [callbackIfReady];\n      }\n    }\n  }\n}\n","export default '0.15.3';\n","import assign from 'object-assign';\n\n// Public API\nimport create from './api/create';\nimport emit from './api/emit';\nimport factory from './api/factory';\nimport fragment from './api/fragment';\nimport init from './api/init';\nimport link from './api/link';\nimport prop, * as properties from './api/prop';\nimport ready from './api/ready';\nimport skate from './api/skate';\nimport state from './api/state';\nimport vdom, * as vdomElements from './api/vdom';\nimport version from './api/version';\n\nassign(prop, properties);\nassign(vdom, vdomElements);\n\nexport default skate;\nexport {\n  create,\n  emit,\n  factory,\n  fragment,\n  init,\n  link,\n  prop,\n  ready,\n  skate,\n  state,\n  vdom,\n  version\n};\n"],"names":["source","target","document","contains","elementPrototypeContains","call","head","body","elem","tagName","tagNameLc","toLowerCase","tagNameDefinition","customElements","get","isAttribute","getAttribute","isAttributeDefinition","element","attrs","attributes","walk","fn","nodeType","Node","ELEMENT_NODE","ignored","chren","childNodes","child","nextSibling","elems","a","length","support","polyfilled","args","forEach","arg","isInDom","elementContains","descendant","component","findElementInRegistry","prototype","createdCallback","attachedCallback","name","props","Ctor","v1","createElement","is","v0","setAttribute","assign","createCustomEvent","opts","CustomEvent","e","createEvent","initCustomEvent","bubbles","cancelable","detail","dispatch","cEvent","disabled","isPropagationStopped","dispatchEvent","createReadableStopPropagation","oldStopPropagation","this","simulateBubbling","didPreventDefault","currentElem","stopPropagation","defineProperty","parentNode","emitOne","shouldSimulateBubbling","undefined","hasBubbleOnDetachedElements","utilElementContains","names","split","reduce","prev","curr","push","namespace","data","__SKATE_DATA","attached","info","detached","attributeChanged","observedAttributes","oldValue","newValue","elemData","isCustomElementsV0","canStartTriggeringNow","isCustomElementsV1","indexOf","propertyName","propData","settingAttribute","settingProperty","propOpts","constructor","properties","deserialize","selector","hasNativeMatchesSelectorDetattachedBug","clone","cloneNode","appendChild","nativeMatchesSelector","readonly","obj","prop","val","parseEvent","indexOfSpace","hasSpace","substring","makeDelegateHandler","handler","parsed","current","matches","makeNormalHandler","bindEvent","event","capture","addEventListener","events","patchAttributeMethods","removeAttribute","attributeChangedCallback","String","called","apply","getDefaultValue","getInitialValue","initial","syncAttribute","attributeName","serializedValue","serialize","empty","createNativePropertyDefinition","created","propertyData","attribute","initialValue","hasAttribute","internalValue","coerce","render","shouldUpdate","set","propertyHasChanged","cancelledEvents","emit","changeData","deb","$debounce","debounce","value","proto","chains","Object","getPrototypeOf","reverse","keys","descriptor","getOwnPropertyDescriptor","isDinosaurBrowser","isConfigurable","configurable","isWritable","writable","getOwnPropertyNames","prototypes","protos","isPrototypeOf","utilGetOwnPropertyDescriptors","ensurePropertyFunctions","descriptors","descriptorName","propertiesInit","ensurePropertyDefinitions","propertyFunctions","callAttributeChangedForEachAttribute","attr","initialiseProperties","propertyDefinitions","definedAttribute","ready","renderedAttribute","applyEvents","eventsApplier","applyPrototype","prototypeApplier","readyCallbacks","isPolyfilled","cb","str","one","two","idx","dash","walkTree","node","childNodesLen","childNode","fixInnerHTML","originalInnerHTML","elementPrototype","_hasBeenEnhanced","html","mutationEvent","initMutationEvent","parent","Element","triggerAddedNodes","addedNodes","triggerRemovedNodes","removedNodes","detachedCallback","documentObserverHandler","mutations","mutationsLength","getClosestIgnoredElement","createMutationObserver","window","MutationObserver","Error","createDocumentObserver","observer","observe","tname","shadowDomV0","slot","createConstructor","func","propKey","ensureLinkedAttributesAreFormatted","tag","fragment","toObject","TypeError","shouldUseNative","test1","test2","i","fromCharCode","order2","map","n","join","test3","letter","hasOwnProperty","propIsEnumerable","propertyIsEnumerable","module","exports","from","symbols","to","s","arguments","key","getOwnPropertySymbols","reservedNames","customElementCriteria","definitions","registerElement","nativeDefinition","HTMLElement","shadowDomV1","elProto","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","raf","requestAnimationFrame","setTimeout","nope","isIeUntil10","test","navigator","userAgent","isIe11","isIe","propertyDescriptor","hasBeenEnhanced","JsMutationObserver","disconnect","Context","notifications","nodesCreated","deleted","nodesDeleted","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMap","keyMapValid","text","inAttributes","inSkip","assertInPatch","context","assertKeyedTagMatches","assertNoUnclosedTags","openElement","root","currentElement","openTags","assertNotInAttributes","functionName","assertNotInSkip","assertInAttributes","assertVirtualAttributesClosed","assertPlaceholderKeySpecified","assertCloseMatchesOpenTag","assertNoChildrenDeclaredYet","previousNode","setInAttributes","previous","setInSkip","markCreated","markDeleted","notifyChanges","create","has","property","initData","getData","applyAttr","el","applyProp","applyStyle","style","cssText","elStyle","applyAttributeTyped","type","updateAttribute","mutator","placeholder","currentNode","currentParent","doc","getNamespaceForTag","namespaceURI","statics","createElementNS","createText","createTextNode","createKeyMap","children","count","getKeyMap","getChild","registerChild","patch","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","prevPreviousNode","previousInAttributes","previousInSkip","ownerDocument","process","env","NODE_ENV","alignWithDOM","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","enterNode","firstChild","nextNode","exitNode","_elementOpen","_elementClose","_text","skip","ATTRIBUTES_OFFSET","argsBuilder","elementOpen","var_args","attrsChanged","j","elementOpenStart","elementOpenEnd","elementClose","elementVoid","elementPlaceholder","formatted","IncrementalDOM.elementOpen","attributes$1","elementOpenEnd$1","dataName","abbr","address","bind","area","aside","audio","b","base","bdi","bdo","bgsound","blockquote","body$1","br","button","canvas","caption","cite","code","col","colgroup","command","content","data$1","datalist","dd","del","details","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head$1","header","hgroup","hr","iframe","image","img","input","ins","kbd","keygen","label","legend","li","link","main","mark","marquee","menu","menuitem","meta","meter","multicol","nav","nobr","noembed","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","rtc","ruby","samp","script","section","select","shadow","small","span","strong","sub","sup","wbr"],"mappings":"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"}